# 性能优化

## 加载优化

### 减少 HTTP 请求

- 合并 CSS, JavaScript
- 合并小图片, 使用雪碧图
- 静态资源尽量使用长 cache(使用文件 hash 更新 cache)

  - 外联式引用 CSS, JavaScript(命中缓存)

### 减少资源体积

- 压缩 HTML, CSS, JavaScript(删除多余的空格, 换行符, 缩进, 注释等)
- 启用 GZip
- 去除无用 CSS([UnCSS](https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Funcss%2Funcss), [purifycss-webpack-plugin](https://github.com/webpack-contrib/purifycss-webpack))
- 去除无用 JavaScript

### 无堵塞加载

- 在 header 使用 `<link>` 方式引入 CSS

  - CSS 文件是并行下载, 不会堵塞页面其他进程, 但会堵塞页面渲染(需要等 CSSOM 构建完成)
  - CSS 加载不会堵塞 DOM 树的解析
  - 不要把内嵌 JavaScript 紧跟在`<link>`标签后面(会导致页面阻塞去等待样式表的下载)

- 异步加载 CSS(不堵塞渲染)

  - 使用 JavaScript 动态创建样式表 `link` 元素，并插入到 DOM 中
  - 将 `link` 元素的 `media` 属性设置为用户浏览器不匹配的媒体类型(或媒体查询), 如 `media="print"`, 甚至可以是完全不存在的类型 `media="noexist"`. 文件加载完成之后, 将 `media` 的值设为 `screen` 或 `all`, 从而让浏览器开始解析 CSS
    - 对浏览器来说，如果样式表不适用于当前媒体类型, 其优先级会被放低, 会在不阻塞页面渲染的情况下再进行下载
    - `<link rel="stylesheet" href="mystyles.css" media="noexist" onload="this.media='all'">`
  - 通过 `rel` 属性将 `link` 元素标记为 `alternate` 可选样式表, 也能实现浏览器异步加载. 加载完成之后，将 `rel` 改回去
    - `<link rel="alternate stylesheet" href="mystyles.css" onload="this.rel='stylesheet'">`
  - `rel="preload"`
    - 使用 `preload`, 比使用不匹配的 `media` 方法能够更早地开始加载 CSS
    - `<link rel="preload" href="mystyles.css" as="style" onload="this.rel='stylesheet'">`
    - as 是必须的. 忽略 as 属性, 或者错误的 as 属性会使 `preload` 等同于 XHR 请求, 浏览器不知道加载的是什么内容, 因此此类资源加载优先级会非常低
    - 不兼容`preload`的解决方案[loadCSS](https://github.com/filamentgroup/loadCSS/tree/v2.0.1#loadcss)

- JavaScript 在页面尾部(`</body>`前)引入

  - JavaScript 会堵塞页面解析和渲染, 因为 js 执行过程中可能会改变页面内容
  - 高版本浏览器中允许并行下载 JavaScript 文件, 但 JavaScript 下载过程仍然会堵塞其他资源的下载, 如图片

- 异步加载 JavaScript, 添加`defer`, `async`属性

  - `async` 是加载完成后自动执行
  - `defer` 需要等待页面完成(DOM 加载完成, window.onload 事件被触发前)后执行

### 首屏加载

- 内联首屏关键 CSS([Critical CSS](https://github.com/filamentgroup/criticalCSS))
  - 内联后的文件大小控制在 14.6kb 以内([初始拥塞窗口](https://tylercipriani.com/blog/2016/09/25/the-14kb-in-the-tcp-initial-window/))
- Node SSR

### 按需加载

- LazyLoad
- 滚屏加载
- 通过 Media Query 加载

### 网络优化

- 多域名并发

* CDN
* code splitting
* tree shaking
* dns-prefetch
* preconnet
* prefetch
* prerender
* webpack DLL
* 骨架屏

## 渲染优化

### 有选择地使用选择器

CSS 选择器的匹配是从右向左进行的, 这一策略导致了不同种类的选择器之间的性能也存在差异. 相比于`#markdown-content-h3`, 显然使用`#markdown .content h3` 时, 浏览器生成渲染树（render-tree）所要花费的时间更多. 因为后者需要先找到 DOM 中的所有 `h3` 元素，再过滤掉祖先元素不是`.content` 的, 最后过滤掉`.content` 的祖先不是`#markdown` 的.

- 不要使用嵌套过多过于复杂的选择器
- 通配符和属性选择器效率最低, 需要匹配的元素最多, 尽量避免使用

### 减少使用昂贵的属性

在浏览器绘制屏幕时, 所有需要浏览器进行操作或计算的属性相对而言都需要花费更大的代价. 当页面发生重绘时, 它们会降低浏览器的渲染性能.

- 减少使用`box-shadow`/`border-radius`/`filter`/`透明度`/`:nth-child`等

### 优化重排(reflow)和重绘(repaint)

- 减少重排

  - 以下操作会触发重排, 应避免频繁触发:

    - 修改字体(`font-size`, `font-family`)
    - 添加/删除样式表
    - 添加或删除可见的 DOM 元素
    - 元素位置改变
    - 元素尺寸改变(包括：外边距、内边距、边框厚度、宽度、高度等属性改变)
    - 内容改变, 例如: 文本改变或图片被另一个不同尺寸的图片替代
    - CSS 伪类激活, 如`a:hover`
    - JS 修改 class 属性
    - JS 设置 style 属性
    - 滚动滚动条或者改变窗口大小

  - 由于每次重排都会产生计算消耗, 大多数浏览器通过队列化修改并批量执行来优化重排过程. 然而, 当获取一些属性时, 浏览器为取得正确的值会强制刷新队列并要求计划任务立刻执行:

    - offsetTop, offsetLeft, offsetWidth, offsetHeight
    - scrollTop, scrollLeft, scrollWidth, scrollHeight
    - clientTop, clientLeft, clientWidth, clientHeight
    - getComputedStyle() (currentStyle in IE)

- 复合图层

  普通文档流可以理解为一个默认复合图层. absolute, fixed 布局可以脱离文档流,但还是属于默认复合图层, 就算 absolute 中信息改变时不会改变普通文档流中 render 树，但是，浏览器最终绘制时，是整个复合层绘制的，所以 absolute 中信息的改变，仍然会影响整个复合层的绘制。（浏览器会重绘它，如果复合层中内容多，absolute 带来的绘制信息变化过大，资源消耗是非常严重的）

  创建新的复合图层, 会单独分配资源(会脱离普通文档流, 将复合图层与默认复合图层隔离开来, 不互相影响, 避免改动引起整个页面重绘, 提升性能):

  - 3D 或透视变换(perspective transform) CSS 属性(`transform`)

    - 3D 和 2D 变换之间的区别在于 3D 变换使浏览器预先创建单独的复合层，而 2D 变换则在运行中进行。 在动画开始时(2D 变换)，会创建一个新的复合图层，并将纹理加载到 GPU，从而启动 repaint。 然后动画由 GPU 中的合成器(Compositor)执行。完成动画后，将该复合图层删除，从而导致另一次 repaint。

  - 使用加速视频解码的`<video>`元素
  - 拥有 3D (WebGL) 上下文或加速的 2D 上下文的 `<canvas>`元素
  - 混合插件(如 Flash)
  - 对自己的 `opacity` 做 CSS 动画或使用一个动画变换的元素
  - 拥有加速 CSS 过滤器的元素, 如 CSS `filter`
  - 元素有一个包含复合层的后代节点(换句话说，就是一个元素拥有一个子元素，该子元素在自己的层里)
  - 元素有一个 z-index 较低且包含一个复合层的兄弟元素(换句话说就是该元素在复合层上面渲染)

  `note:` 如果图层中某个元素需要重绘，那么整个图层都需要重绘。比如一个图层包含很多节点，其中有个 gif 图，gif 图的每一帧，都会重绘整个图层的其他节点，然后生成最终的图层位图。所以这需要通过特殊的方式来强制 gif 图属于自己一个图层（`translateZ(0)`或 `translate3d(0,0,0)`），CSS3 的动画也是一样（好在绝大部分情况浏览器自己会为 CSS3 动画的节点创建图层）

- 最佳实践

  - `Flex`有更好的重排性能, 布局时可优先考虑
  - 尽可能在 DOM 树中比较低的节点上修改元素的 class (缩小 reflow 影响范围)
  - 避免多次设置内联样式(每设置一次都会触发一次 reflow), 应将样式合并为 class, 修改 class 名称(只触发一次 reflow)
    - 或者合并多个样式修改, 一次处理掉: `el.style.cssText = ‘border-left:1px; border-right:2px;’`
  - 批量修改 DOM 时(只触发两次重排, 第一步和第三步)
    - 使元素脱离文档
      - 隐藏元素 `display="none"`
      - 使用文档片段(document fragment)在当前 DOM 之前构建一个子树
      - 将原始元素拷贝到一个脱离文档的节点
    - 对其应用多重改变
    - 把元素带回文档中
  - 对动画元素使用 `fixed` 或 `absolute` 定位，将其脱离文档流, 这样它们不会影响其他元素的 layout, 而只是会造成 repaint
  - 对动画启用[硬件加速](https://www.sitepoint.com/introduction-to-hardware-acceleration-css-animations/)提升性能(`translateZ(0)`, `translate3d(0,0,0)`, `transform`, [will-change](https://www.zhangxinxu.com/wordpress/2015/11/css3-will-change-improve-paint/))
  - 避免使用 table 布局(性能差)
    - 或者使用 table 布局时设置 `table-layout="fixed"`
  - 避免在 CSS 中使用 JavaScript 表达式(每当文档或者部分文档重新加载的时候, CSS 表达式都会重新计算一次)

## 性能优化指标

- 首次有效绘制(First Meaningful Paint，简称 FMP), 即指页面的首要内容(primary content)出现在屏幕上的时间
- 帧率达到 60fps

## 参考资料

- [移动 H5 前端性能优化指南](https://segmentfault.com/a/1190000002511921)
- [CSS 性能优化的 8 个技巧](https://juejin.im/post/5b6133a351882519d346853f)
- [REFLOWS & REPAINTS: CSS PERFORMANCE MAKING YOUR JAVASCRIPT SLOW?](http://www.stubbornella.org/content/2009/03/27/reflows-repaints-css-performance-making-your-javascript-slow/)
- [An Introduction to Hardware Acceleration with CSS Animations](https://www.sitepoint.com/introduction-to-hardware-acceleration-css-animations/)
- [An Introduction to the CSS will-change Property](https://www.sitepoint.com/introduction-css-will-change-property/)
- [使用 CSS3 will-change 提高页面滚动、动画等渲染性能](https://www.zhangxinxu.com/wordpress/2015/11/css3-will-change-improve-paint/)
- [为什么帧率达到 60fps 页面就流畅？](https://www.jianshu.com/p/90319dbf6fe7)
