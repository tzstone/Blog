# 浏览器原理

## 进程与线程

进程可以被描述为是一个应用的执行程序。线程存在于进程并执行程序任意部分。启动应用时会创建一个进程。程序也许会创建一个或多个线程来帮助它工作，这是可选的。操作系统为进程提供了一个可以使用的“一块”内存，所有应用程序状态都保存在该私有内存空间中。关闭应用程序时，相应的进程也会消失，操作系统会释放内存。

![Process and Thread](https://github.com/tzstone/MarkdownPhotos/raw/master/Process%20and%20Thread.png)

进程可以请求操作系统启动另一个进程来执行不同的任务。此时，内存中的不同部分会分给新进程。如果两个进程需要对话，他们可以通过`进程间通信（IPC）`来进行。许多应用都是这样设计的，所以如果一个工作进程失去响应，该进程就可以在不停止应用程序不同部分的其他进程运行的情况下重新启动。

![IPC](https://github.com/tzstone/MarkdownPhotos/raw/master/workerprocess.svg)

### chrome 的多进程架构:

#### `浏览器进程`

- 控制应用中的 “Chrome” 部分，包括地址栏，书签，回退与前进按钮。以及处理 web 浏览器不可见的特权部分，如网络请求与文件访问。
- 包含绘制浏览器按钮和输入栏的 `UI 线程`、处理网络栈以从因特网获取数据的`网络线程`、控制文件访问的`存储线程`等

#### `渲染进程`

- 控制标签页内网站展示。每个标签页都拥有自己独立的渲染进程。

#### `插件进程`

- 控制站点使用的任意插件，如 Flash。

#### `GPU 进程`

- 处理独立于其它进程的 GPU (图形处理器)任务。GPU 被分成不同进程，因为 GPU 处理来自多个不同应用的请求并绘制在相同表面。

## 导航过程

从浏览器进程开始:

1. 开始导航

   当用户在地址栏输入 URL, 并按下 Enter 键时，`UI 线程`启用网络调取去获取站点内容。加载动画会显示在标签页的一角，`网络线程`会通过适当的协议，像 `DNS 查找`和为请求`建立 TLS 连接`。

   在这时，`网络线程`可能会收到像 HTTP 301 那样的服务器重定向头。这种情况下，`网络线程`会告诉 `UI 线程`，服务器正在请求重定向。然后，另一个 URL 请求会被启动。

2. 读取响应

   ![包含 Content-Type 的响应头以及作为实际数据的 payload](https://github.com/tzstone/MarkdownPhotos/raw/master/%E5%8C%85%E5%90%AB%20Content-Type%20%E7%9A%84%E5%93%8D%E5%BA%94%E5%A4%B4%E4%BB%A5%E5%8F%8A%E4%BD%9C%E4%B8%BA%E5%AE%9E%E9%99%85%E6%95%B0%E6%8D%AE%E7%9A%84%20payload.png)

   一旦开始收到响应主体（payload），`网络线程`会在必要时查看数据流的前几个字节。响应报文的 `Content-Type` 字段会声明数据的类型，但是它有可能会丢失或者错误，所以就有了 MIME 类型嗅探来解决这个问题。

   如果响应是一个 HTML 文件，那么下一步就会把数据传给渲染进程，但是如果是一个压缩文件或是其他文件，那么意味着它是一个下载请求，因此需要将数据传递给下载管理器。

   此时也会进行 `SafeBrowsing` 检查。如果域名和响应数据似乎匹配到一个已知的恶意网站，那么网络线程会显示一个警告页面。除此之外，还会发生 `Cross Origin Read Blocking（CORB）`检查，以确保敏感的跨域数据不被传给渲染进程。

3. 查找渲染进程

   一旦所有的检查执行完毕并且`网络线程`确信浏览器会导航到请求的站点，`网络线程`会告诉 `UI 线程`所有的数据准备完毕。`UI 线程`会寻找`渲染进程`去开始渲染 web 页面。

   由于网络请求会花费几百毫秒才获取回响应，因此可以应用一个优化措施。当第 2 步 `UI 线程`正发送一个 URL 请求给`网络线程`时，它已经知道它们会导航到哪个站点。在网络请求的同时，`UI 线程`并行地尝试主动寻找或开启一个`渲染进程`。这样，如果一切按预期进行，`渲染进程`在`网络线程`接受到数据时就已经处于待命状态。如果导航跨域重定向，这个待命进程也许不会被用到，这种情况下也许会用到另一个进程。

4. 提交导航

   现在数据和渲染进程已经就绪，`浏览器进程`会发送一个 IPC（进程间通信）到`渲染进程`去提交导航。它也会传递数据流，所以`渲染进程`可以保持接收 HTML 数据。一旦浏览器进程收到渲染进程已经提交的确认消息，导航完毕并且文档加载解析开始。

   这时，地址栏已经更新，安全指示器和站点设置 UI 会反映新页面的站点信息。此标签页的 session 历史记录会被更新，所以前进/后退按钮会走向刚导航过的站点。当你关闭标签页或者窗口，为了优化 tab/session 的还原，session 历史被保存在硬盘上。

   ![浏览器和渲染进程间的 IPC，请求渲染页面](https://github.com/tzstone/MarkdownPhotos/raw/master/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%92%8C%E6%B8%B2%E6%9F%93%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%20IPC%EF%BC%8C%E8%AF%B7%E6%B1%82%E6%B8%B2%E6%9F%93%E9%A1%B5%E9%9D%A2.png)

5. 初始加载完毕

   一旦导航被提交，`渲染进程`开始加载资源和渲染页面。一旦渲染进程渲染“结束”。它会发送一个 IPC 返回给`浏览器进程`（这会在页面所有的 frame 的 `onload` 事件已经触发并且执行完毕后发生）。这时，`UI 线程`停止标签页上的加载动画。

   我之所以说“结束”，是因为客户端 JavaScript 可以在这时之后仍然加载额外的资源并且渲染新视图。

   ![渲染进程发送 IPC 到浏览器进程通知页面“已被加载”](https://github.com/tzstone/MarkdownPhotos/raw/master/%E6%B8%B2%E6%9F%93%E8%BF%9B%E7%A8%8B%E5%8F%91%E9%80%81%20IPC%20%E5%88%B0%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BF%9B%E7%A8%8B%E9%80%9A%E7%9F%A5%E9%A1%B5%E9%9D%A2%E2%80%9C%E5%B7%B2%E8%A2%AB%E5%8A%A0%E8%BD%BD%E2%80%9D.png)

6. 导航到另一个站点:

   当用户在地址栏输入另一个 URL 会怎样呢？浏览器进程会执行相同的步骤来导航到一个不同的站点。但是在它做这个之前，它会检查当前已经渲染的站点是否关心 `beforeunload` 事件。

   `beforeunload` 可以在你试图导航离开或关闭标签页时创建“离开此站点？”警告。包括你的 JavaScript 代码，所有标签页内的东西都是由`渲染进程`处理，所以当新的导航请求到来时，`浏览器进程`必须要跟当前的`渲染进程`核对。

   注意： 不要添加无条件的 `beforeunload` 处理程序。它会产生更多`延迟`，因为处理程序需要在导航开始之前执行。应仅在需要时添加此事件处理程序，例如如果需要警告用户他们可能会丢失他们在页面上输入的数据。

   ![浏览器进程向渲染进程发送 IPC 告诉它将要导航到另一个站点](https://github.com/tzstone/MarkdownPhotos/raw/master/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BF%9B%E7%A8%8B%E5%90%91%E6%B8%B2%E6%9F%93%E8%BF%9B%E7%A8%8B%E5%8F%91%E9%80%81%20IPC%20%E5%91%8A%E8%AF%89%E5%AE%83%E5%B0%86%E8%A6%81%E5%AF%BC%E8%88%AA%E5%88%B0%E5%8F%A6%E4%B8%80%E4%B8%AA%E7%AB%99%E7%82%B9.png)

   如果渲染进程已经启动了导航（像用户点击一个链接或者客户端 JavaScript 运行 `window.location = "https://newsite.com"`），渲染进程会先检查 `beforeunload` 事件处理程序。然后，它会像浏览器处理启动导航一样执行相同的步骤。唯一不同的是导航请求是由`渲染进程`发送到`浏览器进程`的。

   当新导航到的站点不同于当前已渲染的站点时，会调用一个独立的渲染进程来处理新导航，同时保持当前的渲染进程来处理类似 `unload` 的事件。

   ![2 个 IPC（从浏览器进程到新渲染进程）告知渲染页面并告知旧渲染进程卸载](https://github.com/tzstone/MarkdownPhotos/raw/master/2%20%E4%B8%AA%20IPC%EF%BC%88%E4%BB%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BF%9B%E7%A8%8B%E5%88%B0%E6%96%B0%E6%B8%B2%E6%9F%93%E8%BF%9B%E7%A8%8B%EF%BC%89%E5%91%8A%E7%9F%A5%E6%B8%B2%E6%9F%93%E9%A1%B5%E9%9D%A2%E5%B9%B6%E5%91%8A%E7%9F%A5%E6%97%A7%E6%B8%B2%E6%9F%93%E8%BF%9B%E7%A8%8B%E5%8D%B8%E8%BD%BD.png)

### `Service Worker`:

service worker 是一种在你的应用代码中编写网络代理的方法；允许 Web 开发者更好地控制本地缓存内容以及何时从网络获取新数据。如果将 service worker 设置为从缓存加载页面，则无需从网络请求数据。Service Worker 是在`渲染进程`中运行的 JavaScript 代码。但是当导航请求进入时，浏览器进程如何知道该站点有 service worker？

当注册一个 service worker 时，保持 service worker 的`作用域`作为一个引用（你可以在这篇文章 [The Service Worker Lifecycle](https://developers.google.com/web/fundamentals/primers/service-workers/lifecycle) 中阅读更多关于作用域的知识）。当一个导航发生时，`网络线程`用已注册的 service worker 作用域来检查域名，如果已经为该 URL 注册了一个 service worker，`UI 线程`会找一个`渲染线程`来执行 service worker 的代码。service worker 可能从缓存中加载数据，无需从网络请求数据，或者可以从网络请求新资源。

![浏览器进程中的网络线程查找 service worker 作用域](https://github.com/tzstone/MarkdownPhotos/raw/master/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BF%9B%E7%A8%8B%E4%B8%AD%E7%9A%84%E7%BD%91%E7%BB%9C%E7%BA%BF%E7%A8%8B%E6%9F%A5%E6%89%BE%20service%20worker%20%E4%BD%9C%E7%94%A8%E5%9F%9F.png)

![浏览器中的 UI 线程启动渲染进程来处理 service workers；然后，渲染进程中的工作线程从网络请求数据](https://github.com/tzstone/MarkdownPhotos/raw/master/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84%20UI%20%E7%BA%BF%E7%A8%8B%E5%90%AF%E5%8A%A8%E6%B8%B2%E6%9F%93%E8%BF%9B%E7%A8%8B%E6%9D%A5%E5%A4%84%E7%90%86%20service%20workers%EF%BC%9B%E7%84%B6%E5%90%8E%EF%BC%8C%E6%B8%B2%E6%9F%93%E8%BF%9B%E7%A8%8B%E4%B8%AD%E7%9A%84%E5%B7%A5%E4%BD%9C%E7%BA%BF%E7%A8%8B%E4%BB%8E%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E6%95%B0%E6%8D%AE.png)

如果 service worker 最终决定从网络请求数据，则浏览器进程和渲染器进程之间的往返可能会导致延迟。`导航预加载`是一种通过与 service worker 启动并行加载资源来加速此过程的机制。它用一个头部来标记这些请求，允许服务器决定为这些请求发送不同的内容；例如，只更新数据而不是完整文档。

![浏览器进程中的 UI 线程启动渲染进程以在并行启动网络请求的同时处理 service worker](https://github.com/tzstone/MarkdownPhotos/raw/master/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BF%9B%E7%A8%8B%E4%B8%AD%E7%9A%84%20UI%20%E7%BA%BF%E7%A8%8B%E5%90%AF%E5%8A%A8%E6%B8%B2%E6%9F%93%E8%BF%9B%E7%A8%8B%E4%BB%A5%E5%9C%A8%E5%B9%B6%E8%A1%8C%E5%90%AF%E5%8A%A8%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E7%9A%84%E5%90%8C%E6%97%B6%E5%A4%84%E7%90%86%20service%20worker.png)

## 渲染过程

渲染进程负责标签页内发生的所有事情。渲染进程内部包含`主线程`、`工作线程`、`合成线程`和`光栅线程`。在渲染进程中，`主线程`处理服务器发送到用户的大部分代码。如果你使用 web worker 或 service worker，部分 JavaScript 将由`工作线程(worker threads)`处理。`合成`和`光栅线程`也在渲染进程内运行，以高效，流畅地呈现页面。渲染进程的核心工作是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页。

![渲染进程内部包含主线程、工作线程、合成线程和光栅线程](https://github.com/tzstone/MarkdownPhotos/raw/master/%E6%B8%B2%E6%9F%93%E8%BF%9B%E7%A8%8B%E5%86%85%E9%83%A8%E5%8C%85%E5%90%AB%E4%B8%BB%E7%BA%BF%E7%A8%8B%E3%80%81%E5%B7%A5%E4%BD%9C%E7%BA%BF%E7%A8%8B%E3%80%81%E5%90%88%E6%88%90%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%85%89%E6%A0%85%E7%BA%BF%E7%A8%8B.png)

### 解析（Parsing）

- DOM 的构建

  当渲染进程收到导航的提交消息并开始接收 HTML 数据时，`主线程`开始解析文本字符串（HTML）并将其转换为`文档对象模型（DOM）`。DOM 是一个页面在浏览器内部表现，也是 Web 开发人员可以通过 JavaScript 与之交互的数据结构和 API。

  将 HTML 到 DOM 的解析由 [HTML Standard](https://html.spec.whatwg.org/) 规定。你可能已经注意到，将 HTML 提供给浏览器这一过程从不会引发错误。像 `Hi! <b>I'm <i>Chrome</b>!</i> `这样的错误标记，会被理解为 `Hi! <b>I'm <i>Chrome</i></b><i>!</i>`，这是因为 HTML 规范会优雅地处理这些错误。如果你好奇这是如何做到的，可以阅读 [An introduction to error handling and strange cases in the parser](https://html.spec.whatwg.org/multipage/parsing.html#an-introduction-to-error-handling-and-strange-cases-in-the-parser) 的 HTML 规范部分。

  ![主线程解析 HTML 并构建 DOM 树](https://github.com/tzstone/MarkdownPhotos/raw/master/%E4%B8%BB%E7%BA%BF%E7%A8%8B%E8%A7%A3%E6%9E%90%20HTML%20%E5%B9%B6%E6%9E%84%E5%BB%BA%20DOM%20%E6%A0%91.png)

- 子资源加载

  网站通常使用图像、CSS 和 JavaScript 等外部资源，这些文件需要从网络或缓存加载。在解析构建 DOM 时，`主线程`会按处理顺序逐个请求它们(one by one as they find them)，但为了加快速度，“`预加载扫描器（preload scanner）`”会同时运行。如果 HTML 文档中有 `<img>` 或 `<link>` 之类的内容，则预加载扫描器会查看由 HTML 解析器生成的标记(tokens)，并在`浏览器进程`中向`网络线程`发送请求。

  当 HTML 解析器遇到 `<script>` 标记时，会`暂停解析` HTML 文档，开始加载、解析并执行 JavaScript 代码。为什么？因为 JavaScript 可以使用诸如 `document.write()` 的方法来改写文档，这会改变整个 DOM 结构（HTML 规范里的 [overview of the parsing model](https://html.spec.whatwg.org/multipage/parsing.html#overview-of-the-parsing-model) 中有一张不错的图片）。这就是 HTML 解析器必须等待 JavaScript 运行后再继续解析 HTML 文档原因。如果你对 JavaScript 执行中发生的事情感到好奇，可以看看 [V8 团队就此发表的演讲和博客文章](https://mathiasbynens.be/notes/shapes-ics)。

  Web 开发者可以通过多种方式向浏览器发送提示，以便很好地加载资源。如果你的 JavaScript 不使用 `document.write()`，你可以在 `<script>` 标签添加 `async` 或 `defer` 属性，这样浏览器会异步加载运行 JavaScript 代码，而不阻塞解析。如果合适，你也可以使用 [JavaScript 模块](https://developers.google.com/web/fundamentals/primers/modules)。可以使用 `<link rel="preload">` 告知浏览器当前导航肯定需要该资源，并且你希望尽快下载。有关详细信息请参阅 [Resource Prioritization – Getting the Browser to Help You](https://developers.google.com/web/fundamentals/performance/resource-prioritization)。

### 样式计算

- 只拥有 DOM 不足以确定页面的外观，因为我们会在 CSS 中设置页面元素的样式。主线程解析 CSS 并确定每个 DOM 节点计算后的样式。这是有关基于 CSS 选择器对每个元素应用何种样式的信息，这可以在 DevTools 的 `computed` 部分中看到。即使你不提供任何 CSS，每个 DOM 节点都具有计算样式。像 `<h1>` 标签看起来比 `<h2>` 标签大，每个元素都有 margin，这是因为浏览器具有默认样式表。

  ![主线程解析 CSS 以添加计算后样式](https://github.com/tzstone/MarkdownPhotos/raw/master/%E4%B8%BB%E7%BA%BF%E7%A8%8B%E8%A7%A3%E6%9E%90%20CSS%20%E4%BB%A5%E6%B7%BB%E5%8A%A0%E8%AE%A1%E7%AE%97%E5%90%8E%E6%A0%B7%E5%BC%8F.png)

### 布局

- 现在，渲染进程知道文档的结构和每个节点的样式，但这不足以渲染页面。布局是计算元素`几何形状`的过程。主线程遍历 DOM，计算样式并创建`布局树(layout tree)`。布局树包含 `x y 坐标`和`边界框大小(bounding box sizes)`等信息。布局树可能与 DOM 树结构类似，但它仅包含页面上`可见内容`相关的信息。如果一个元素应用了 `display：none`，那么该元素不是布局树的一部分（但 `visibility：hidden` 的元素在布局树中）。类似地，如果应用了如 `p::before{content:"Hi!"}` 的伪类，则即使它不在 DOM 中，也包含于布局树中。

  确定页面布局是一项很有挑战性的任务。即使是从上到下的块流这样最简单的页面布局，也必须考虑字体的大小以及换行位置，这些因素会影响段落的大小和形状，进而影响下一个段落的位置。

  ![主线程遍历计算样式后的 DOM 树，以此生成布局树](https://github.com/tzstone/MarkdownPhotos/raw/master/%E4%B8%BB%E7%BA%BF%E7%A8%8B%E9%81%8D%E5%8E%86%E8%AE%A1%E7%AE%97%E6%A0%B7%E5%BC%8F%E5%90%8E%E7%9A%84%20DOM%20%E6%A0%91%EF%BC%8C%E4%BB%A5%E6%AD%A4%E7%94%9F%E6%88%90%E5%B8%83%E5%B1%80%E6%A0%91.png)

### 绘制

- 拥有 DOM、样式和布局仍然不足以渲染页面。假设你正在尝试重现一幅画。你知道元素的大小、形状和位置，但你仍需要判断绘制它们的`顺序`。例如，可以为某些元素设置 `z-index`，此时按 HTML 中编写的元素的顺序绘制会导致错误的渲染。在绘制步骤中，主线程遍历`布局树( layout tree)`创建`绘制记录(paint records)`。绘制记录是绘图过程的记录，就像是“背景优先，然后是文本，然后是矩形”。如果你使用过 JavaScript 绘制了 `<canvas>` 元素，那么这个过程对你来说可能很熟悉。

  ![主线程遍历布局树并生成绘制记录](https://github.com/tzstone/MarkdownPhotos/raw/master/%E4%B8%BB%E7%BA%BF%E7%A8%8B%E9%81%8D%E5%8E%86%E5%B8%83%E5%B1%80%E6%A0%91%E5%B9%B6%E7%94%9F%E6%88%90%E7%BB%98%E5%88%B6%E8%AE%B0%E5%BD%95.png)

- 更新渲染管道(rendering pipeline)

  ![DOM + Style、布局和绘制树的生成顺序](https://github.com/tzstone/MarkdownPhotos/raw/master/DOM%20%2B%20Style%E3%80%81%E5%B8%83%E5%B1%80%E5%92%8C%E7%BB%98%E5%88%B6%E6%A0%91%E7%9A%84%E7%94%9F%E6%88%90%E9%A1%BA%E5%BA%8F.gif)

  渲染管道中最重要的事情是：每个步骤中，前一个操作的结果都用于创建新数据(style->layout->paint)。例如，如果布局树中的某些内容发生改变，需要为文档的受影响部分重新生成`绘制顺序(paint order)`。

  如果要为元素设置动画，则浏览器必须在每个帧之间运行这些操作。大多数显示器每秒刷新屏幕 60 次（60 fps），当屏幕每帧都在变化，人眼会觉得动画很流畅。但是，如果动画丢失了中间一些帧，页面看起来就会卡顿（janky）。

  ![时间轴上的动画帧](https://github.com/tzstone/MarkdownPhotos/raw/master/%E6%97%B6%E9%97%B4%E8%BD%B4%E4%B8%8A%E7%9A%84%E5%8A%A8%E7%94%BB%E5%B8%A7.png)

  即使渲染操作能跟上屏幕刷新，这些计算也会在`主线程`上运行，这意味着当你的应用程序运行 JavaScript 时动画可能会被阻塞。

  ![时间轴上的动画帧，但 JavaScript 阻塞了一帧](https://github.com/tzstone/MarkdownPhotos/raw/master/%E6%97%B6%E9%97%B4%E8%BD%B4%E4%B8%8A%E7%9A%84%E5%8A%A8%E7%94%BB%E5%B8%A7%EF%BC%8C%E4%BD%86%20JavaScript%20%E9%98%BB%E5%A1%9E%E4%BA%86%E4%B8%80%E5%B8%A7.png)

  你可以将 JavaScript 操作划分为小块，并使用 `requestAnimationFrame()` 在每个帧上运行。有关此主题的更多信息，请参阅 [Optimize JavaScript Execution](https://developers.google.com/web/fundamentals/performance/rendering/optimize-javascript-execution)。你也可以在 [Web Worker](https://www.youtube.com/watch?v=X57mh8tKkgE) 中运行 JavaScript 以避免阻塞主线程。

  ![时间轴上较小的 JavaScript 块与动画帧一起运行](https://github.com/tzstone/MarkdownPhotos/raw/master/%E6%97%B6%E9%97%B4%E8%BD%B4%E4%B8%8A%E8%BE%83%E5%B0%8F%E7%9A%84%20JavaScript%20%E5%9D%97%E4%B8%8E%E5%8A%A8%E7%94%BB%E5%B8%A7%E4%B8%80%E8%B5%B7%E8%BF%90%E8%A1%8C.png)

### 合成

- 现在浏览器知道文档的结构、每个元素的样式、页面的几何形状和绘制顺序，它是如何绘制页面的？把这些信息转换为屏幕上的`像素`，我们称为`光栅化`。

  处理这种情况的一种简单的方法是，先在光栅化视窗内(viewport)的画面，如果用户滚动页面，则移动光栅框，并光栅化填充缺少的部分。这就是 Chrome 首次发布时处理光栅化的方式。但是，现代浏览器会运行一个更复杂的过程，我们称为合成。

  ![简单光栅处理示意动画](https://github.com/tzstone/MarkdownPhotos/raw/master/%E7%AE%80%E5%8D%95%E5%85%89%E6%A0%85%E5%A4%84%E7%90%86%E7%A4%BA%E6%84%8F%E5%8A%A8%E7%94%BB.gif)

  `合成`是一种将页面的各个部分`分层`，分别`光栅化`，并在称为`合成线程`的单独线程中`合成为页面`的技术。如果发生滚动，由于图层已经光栅化，因此它所要做的只是合成一个新帧。动画也可以以相同的方式（移动图层和合成新帧）实现。

  ![合成处理示意动画](https://github.com/tzstone/MarkdownPhotos/raw/master/%E5%90%88%E6%88%90%E5%A4%84%E7%90%86%E7%A4%BA%E6%84%8F%E5%8A%A8%E7%94%BB.gif)

  你可以在 DevTools 使用 [Layers 面板](https://blog.logrocket.com/eliminate-content-repaints-with-the-new-layers-panel-in-chrome-e2c306d4d752?gi=cd6271834cea) 看看你的网站如何被分层。

- 分层

  为了分清哪些元素位于哪些图层，主线程遍历`布局树(layout tree)`创建`图层树(layer tree)`（此部分在 DevTools 性能面板中称为“Update Layer Tree”）。如果页面的某些部分应该是单独图层（如滑入式侧面菜单）但没拆分出来，你可以使用 CSS 中的 `will-change` 属性来提示浏览器。

  ![主线程遍历布局树生成图层树](https://github.com/tzstone/MarkdownPhotos/raw/master/%E4%B8%BB%E7%BA%BF%E7%A8%8B%E9%81%8D%E5%8E%86%E5%B8%83%E5%B1%80%E6%A0%91%E7%94%9F%E6%88%90%E5%9B%BE%E5%B1%82%E6%A0%91.png)

  你可能想要为每个元素都分层，但是合成大量的图层可能会比每帧都光栅化页面的刷新方式更慢，因此测量应用程序的渲染性能至关重要。有关这个主题的更多信息，请参阅 [Stick to Compositor-Only Properties and Manage Layer Count](https://developers.google.com/web/fundamentals/performance/rendering/stick-to-compositor-only-properties-and-manage-layer-count)。

- 主线程的光栅化和合成

  一旦创建了`图层树( layer tree)`并确定了`绘制顺序(paint orders)`，主线程就会将该信息提交给`合成线程`。接着，合成线程会光栅化每个图层。一个图层可能会跟整个页面一样大，因此`合成线程`将它们分块(tiles)后发送到`光栅线程(Raster thread)`。光栅线程光栅化每个小块后会将它们存储在显存(GPU memory)中。

  ![光栅线程创建分块的位图并发送到 GPU](https://github.com/tzstone/MarkdownPhotos/raw/master/%E5%85%89%E6%A0%85%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA%E5%88%86%E5%9D%97%E7%9A%84%E4%BD%8D%E5%9B%BE%E5%B9%B6%E5%8F%91%E9%80%81%E5%88%B0%20GPU.png)

  合成线程(compositor thread)会给不同的光栅线程设置优先级，以便视窗（或附近）内的画面可以先被光栅化。图层还具有多个不同分辨率的块(tilings)，可以处理放大(zoom-in)等操作。

  一旦块(tiles)被光栅化，合成线程会收集这些块的信息（称为`绘制四边形(draw quads)`）来创建`合成帧(compositor frame)`。

  - 绘制四边形

    包含诸如图块在内存中的位置，以及合成时绘制图块在页面中的位置等信息。

  - 合成帧

    一个绘制四边形的集合，代表一个页面的一帧。

  接着，`合成帧`通过 IPC（进程间通讯）提交给`浏览器进程`。此时，可以从 `UI 线程`或其他插件的渲染进程添加另一个合成帧。这些合成器帧被发送到 `GPU` 然后在屏幕上显示。如果接收到滚动事件，合成线程会创建另一个合成帧发送到 GPU。

  ![合成线程创建合成帧，将其发送到浏览器进程，再接着发送到 GPU](https://github.com/tzstone/MarkdownPhotos/raw/master/%E5%90%88%E6%88%90%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA%E5%90%88%E6%88%90%E5%B8%A7%EF%BC%8C%E5%B0%86%E5%85%B6%E5%8F%91%E9%80%81%E5%88%B0%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BF%9B%E7%A8%8B%EF%BC%8C%E5%86%8D%E6%8E%A5%E7%9D%80%E5%8F%91%E9%80%81%E5%88%B0%20GPU.png)

  `合成的好处是它可以在不涉及主线程的情况下完成。合成线程不需要等待样式计算或 JavaScript 执行。`这就是为什么[仅合成动画](https://www.html5rocks.com/en/tutorials/speed/high-performance-animations/)被认为是流畅性能的最佳选择。`如果需要再次计算布局或绘制，则必须涉及主线程。`

## 交互过程

- 浏览器视角下的输入事件

  浏览器眼中，输入意味着一切用户行为。不单滚动鼠标滑轮是输入事件，触摸屏幕、滑动鼠标同样也是用户输入事件。诸如触摸屏幕之类用户手势产生时，浏览器进程会率先将其捕获。然而浏览器进程所掌握的信息仅限于行为发生的区域，因为标签页里的内容都由渲染进程负责处理，所以`浏览器进程`会将事件类型（如 `touchstart`）及其坐标发送给`渲染进程`。渲染进程会寻至事件目标，运行其事件监听器，妥善地处理事件。

  ![输入事件由浏览器进程发往渲染进程](https://github.com/tzstone/MarkdownPhotos/raw/master/%E8%BE%93%E5%85%A5%E4%BA%8B%E4%BB%B6%E7%94%B1%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BF%9B%E7%A8%8B%E5%8F%91%E5%BE%80%E6%B8%B2%E6%9F%93%E8%BF%9B%E7%A8%8B.png)

- 合成器接收输入事件

  在上篇文章里，我们探讨了合成器如何通过合成栅格化图层，实现流畅的页面滚动。如果页面上没有添加任何事件监听，合成线程会独立于主线程创建一个的新合成帧。但要是页面上添加了事件监听呢？合成线程又是如何得知事件是否需要处理的？

  - 非立即可滚动区

    因为运行 JavaScript 脚本是`主线程`的工作，所以页面合成后，合成线程会将页面里添加了`事件监听`的区域标记为“`非立即可滚动区(Non-Fast Scrollable Region)`”。有了这个信息，如果输入事件发生在这一区域，合成线程可以确定应将其发往主线程处理。如输入事件发生在这一区域之外，合成线程则确定无需等待主线程，可继续合成新帧。

    ![非立即可滚动区输入描述示意图](https://github.com/tzstone/MarkdownPhotos/raw/master/%E9%9D%9E%E7%AB%8B%E5%8D%B3%E5%8F%AF%E6%BB%9A%E5%8A%A8%E5%8C%BA%E8%BE%93%E5%85%A5%E6%8F%8F%E8%BF%B0%E7%A4%BA%E6%84%8F%E5%9B%BE.png)

  - 设置事件处理器时须注意

    web 开发中常用的事件处理模式是事件代理。因为事件会冒泡，所以你可以在最顶层的元素中添加一个事件处理器，用来代理事件目标产生的任务。下面这样的代码，你可能见过，或许也写过。

    ```javascript
    document.body.addEventListener('touchstart', (event) => {
      if (event.target === area) {
        event.preventDefault();
      }
    });
    ```

    这样只需添加一个事件监听器，即可监听所有元素，的确十分省事。然而，如果站在浏览器的角度去考量，这等于把整个页面都标记成了“`非立即可滚动区`”，意味着即便你设计的应用本不必理会页面上一些区域的输入行为，合成线程也必须在每次输入事件产生后与主线程通信并等待返回。如此则得不偿失，使原本能保障页面滚动流畅的合成器没了用武之地。

    ![非立即可滚动区覆盖整个页面下的输入描述示意图](https://github.com/tzstone/MarkdownPhotos/raw/master/%E9%9D%9E%E7%AB%8B%E5%8D%B3%E5%8F%AF%E6%BB%9A%E5%8A%A8%E5%8C%BA%E8%A6%86%E7%9B%96%E6%95%B4%E4%B8%AA%E9%A1%B5%E9%9D%A2%E4%B8%8B%E7%9A%84%E8%BE%93%E5%85%A5%E6%8F%8F%E8%BF%B0%E7%A4%BA%E6%84%8F%E5%9B%BE.png)

    你可以给事件监听添加一个 `passive:true` 选项 ，将这种负面效果最小化。这会提示浏览器你想继续在主线程中监听事件，但合成器不必停滞等候，可接着创建新的合成帧。

    ```javascript
    document.body.addEventListener(
      'touchstart',
      (event) => {
        if (event.target === area) {
          event.preventDefault();
        }
      },
      { passive: true },
    );
    ```

    - passive

      A Boolean that, if true, indicates that the function specified by listener will never call `preventDefault()`

      According to the specification, the default value for the `passive` option is always `false`. However, this introduces the potential for event listeners handling certain touch events (among others) to block the browser's main thread while it is attempting to handle scrolling, resulting in possibly enormous reduction in performance during scroll handling.

      To prevent this problem, some browsers (specifically, Chrome and Firefox) have changed the default value of the `passive` option to `true` for the `touchstart` and `touchmove` events on the document-level nodes `Window`, `Document`, and `Document.body`. This prevents the event listener from being called, so it can't block page rendering while the user is scrolling.

- 检查事件是否可撤销

  ![部分区域仅可水平方向滚动的网页](https://github.com/tzstone/MarkdownPhotos/raw/master/%E9%83%A8%E5%88%86%E5%8C%BA%E5%9F%9F%E4%BB%85%E5%8F%AF%E6%B0%B4%E5%B9%B3%E6%96%B9%E5%90%91%E6%BB%9A%E5%8A%A8%E7%9A%84%E7%BD%91%E9%A1%B5.png)

  设想一下这种情形：页面上有一个盒子，你要将其滚动方向限制为水平滚动。为目标事件设置 `passive:true` 选项可让页面滚动平滑，但在你使用 `preventDefault` 以限制滚动方向时，垂直方向滚动可能已经触发。使用 `event.cancelable` 可以检查并阻止这种情况发生。

  ```javascript
  document.body.addEventListene(
    'pointermove',
    (event) => {
      if (event.cancelable) {
        event.preventDefault(); // 阻止默认的滚动行为
        /*
         *  这里设置程序执行任务
         */
      }
    },
    { passive: true },
  );
  ```

  或者，你也可以应用 `touch-action` 这类 CSS 规则，完全地将事件处理器屏蔽掉。

  ```html
  #area { touch-action: pan-x; }
  ```

- 定位事件目标

  ![主线程检查绘制记录查询坐标 x、y 处绘制内容](https://github.com/tzstone/MarkdownPhotos/raw/master/%E4%B8%BB%E7%BA%BF%E7%A8%8B%E6%A3%80%E6%9F%A5%E7%BB%98%E5%88%B6%E8%AE%B0%E5%BD%95%E6%9F%A5%E8%AF%A2%E5%9D%90%E6%A0%87%20x%E3%80%81y%20%E5%A4%84%E7%BB%98%E5%88%B6%E5%86%85%E5%AE%B9.png)

  合成器将输入事件发送至主线程后，首先运行的是`命中检测`。命中检测会使用渲染进程中产生的绘制记录数据，找出事件发生坐标下的内容。

- 降低往主线程发送事件的频率

  之前的文章里，我们探讨了常见显示屏如何以每秒 60 帧的频率刷新，以及我们要怎样与其刷新频率保持步调一致，以营造出流畅的动画效果。而对于用户的输入行为，常见触摸屏设备的事件传输频率为每秒 60~120 次，常见鼠标设备的事件传输频率为每秒 100 次。可见，输入事件有着比显示屏幕更高的保真度。

  如果一连串 `touchmove` 这样的事件以每秒 120 次的频率发送往主线程，那么可能会触发过量的命中检测及 JavaScript 脚本执行。相形而言，我们的屏幕刷新率则低下得多。

  ![大量事件涌入合成帧时间轴会造成页面闪烁](https://github.com/tzstone/MarkdownPhotos/raw/master/%E5%A4%A7%E9%87%8F%E4%BA%8B%E4%BB%B6%E6%B6%8C%E5%85%A5%E5%90%88%E6%88%90%E5%B8%A7%E6%97%B6%E9%97%B4%E8%BD%B4%E4%BC%9A%E9%80%A0%E6%88%90%E9%A1%B5%E9%9D%A2%E9%97%AA%E7%83%81.png)

  为了降低往主线程中传递过量调用，Chrome 会合并(coalesces)这些连续事件（如：`wheel`, `mousewheel`, `mousemove`, `pointermove`, `touchmove` 等），并将其延迟至下一次 `requestAnimationFrame` 前发送。

  ![相同的时间轴下事件被合并且延迟发送](https://github.com/tzstone/MarkdownPhotos/raw/master/%E7%9B%B8%E5%90%8C%E7%9A%84%E6%97%B6%E9%97%B4%E8%BD%B4%E4%B8%8B%E4%BA%8B%E4%BB%B6%E8%A2%AB%E5%90%88%E5%B9%B6%E4%B8%94%E5%BB%B6%E8%BF%9F%E5%8F%91%E9%80%81.png)

  所有独立的事件，如: `keydown`, `keyup`, `mouseup`, `mousedown`, `touchstart`, 及 `touchend` 则会立即发往主线程。

  - 使用 `getCoalescedEvents` 获取帧内事件

    事件合并可帮助大多数 web 应用构建良好的用户体验。然而，如果你开发的是一个绘图类应用，需要基于 `touchmove` 事件的坐标绘制线路，那么在你试图画下一根光滑的线条时，区间内的一些坐标点也可能会因事件合并而丢失。这时，你可以使用目标事件的 `getCoalescedEvents` 方法获取事件合并后的信息。

    ![左为流畅的触摸手势路径、右为事件合并后的有限路径](https://github.com/tzstone/MarkdownPhotos/raw/master/%E5%B7%A6%E4%B8%BA%E6%B5%81%E7%95%85%E7%9A%84%E8%A7%A6%E6%91%B8%E6%89%8B%E5%8A%BF%E8%B7%AF%E5%BE%84%E3%80%81%E5%8F%B3%E4%B8%BA%E4%BA%8B%E4%BB%B6%E5%90%88%E5%B9%B6%E5%90%8E%E7%9A%84%E6%9C%89%E9%99%90%E8%B7%AF%E5%BE%84.png)

    ```javascript
    window.addEventListener('pointermove', (event) => {
      const events = event.getCoalescedEvents();
      for (let event of events) {
        const x = event.pageX;
        const y = event.pageY;
        // 使用 x、y 坐标画线
      }
    });
    ```

### GUI 渲染线程

- 负责渲染浏览器界面，解析 HTML，CSS，构建 DOM 树和 RenderObject 树，布局和绘制等。当界面需要`重绘（Repaint）`或由于某种操作引发`回流(reflow)`时，该线程就会执行。
- 注意，`GUI 渲染线程`与 `JS 引擎线程`是互斥的，当 `JS 引擎`执行时 `GUI 线程`会被挂起（相当于被冻结了），GUI 更新会被保存在一个队列中等到 JS 引擎空闲时立即被执行。

### JS 引擎线程

- `JS 引擎线程`负责解析 Javascript 脚本，运行代码。JS 引擎一直等待着任务队列中任务的到来，然后加以处理，一个 Tab 页（renderer 进程）中无论什么时候都只有一个 JS 线程在运行 JS 程序。
- 同样注意，`GUI 渲染线程`与 `JS 引擎线程`是互斥的，所以如果 JS 执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。

### 事件触发线程

- 归属于浏览器而不是 JS 引擎，用来控制事件循环。当 JS 引擎执行代码块如 setTimeOut 时（也可来自浏览器内核的其他线程,如鼠标点击、AJAX 异步请求等），会将对应任务添加到事件线程中. 当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待 JS 引擎的处理
- 注意，由于 JS 的单线程关系，所以这些待处理队列中的事件都得排队等待 JS 引擎处理（当 JS 引擎空闲时才会去执行）

### 定时器触发线程

- setInterval 与 setTimeout 所在线程。浏览器定时计数器并不是由 JavaScript 引擎计数的,（因为 JavaScript 引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确）. 因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待 JS 引擎空闲后执行）
- 注意，W3C 在 HTML 标准中规定，规定要求 setTimeout 中低于 4ms 的时间间隔算为 4ms。

### 异步 http 请求线程

- 在 XMLHttpRequest 在连接后是通过浏览器新开一个线程请求。当检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由 JavaScript 引擎执行。

## Event Loop

参考资料

[Tasks, microtasks, queues and schedules](https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/)

[JavaScript 运行机制详解：再谈 Event Loop](http://www.ruanyifeng.com/blog/2014/10/event-loop.html)

[[译]现代浏览器内部揭秘（第一部分）](https://juejin.cn/post/6844903679389073415)

[[译]现代浏览器内部揭秘（第二部分）](https://juejin.cn/post/6844903692890537992)

[[译]现代浏览器内部揭秘（第三部分）](https://juejin.cn/post/6844903692894732295)

[[译]现代浏览器内部揭秘（第四部分）](https://juejin.cn/post/6844903695600058375)

```

```

```

```

```

```
