# 浏览器原理

## 浏览器的高层结构

浏览器的主要组件为：

- 用户界面 - 包括地址栏、前进/后退按钮、书签菜单等。除了浏览器主窗口显示的您请求的页面外，其他显示的各个部分都属于用户界面。
- 浏览器引擎 - 在用户界面和渲染引擎之间传送指令。
- 渲染引擎 - 负责显示请求的内容。如果请求的内容是 HTML，它就负责解析 HTML 和 CSS 内容，并将解析后的内容显示在屏幕上。
- 网络 - 用于网络调用，比如 HTTP 请求。其接口与平台无关，并为所有平台提供底层实现。
- 用户界面后端 - 用于绘制基本的窗口小部件，比如组合框和窗口。其公开了与平台无关的通用接口，而在底层使用操作系统的用户界面方法。
- JavaScript 解释器。用于解析和执行 JavaScript 代码。
- 数据存储。这是持久层。浏览器需要在硬盘上保存各种数据，例如 Cookie。新的 HTML 规范 (HTML5) 定义了“网络数据库”，这是一个完整（但是轻便）的浏览器内数据库。

  ![浏览器的主要组件](https://github.com/tzstone/MarkdownPhotos/raw/master/layers.png)

### 渲染引擎

默认情况下，渲染引擎可显示 HTML 和 XML 文档与图片。通过插件（或浏览器扩展程序），还可以显示其他类型的内容；例如，使用 PDF 查看器插件就能显示 PDF 文档。但是在本章中，我们将集中介绍其主要用途：显示使用 CSS 格式化的 HTML 内容和图片。

本文所讨论的浏览器（Firefox、Chrome 浏览器和 Safari）是基于两种渲染引擎构建的。Firefox 使用的是 `Gecko`，这是 Mozilla 公司“自制”的渲染引擎。而 Safari 和 Chrome 浏览器使用的都是 `WebKit`。

WebKit 是一种开放源代码渲染引擎，起初用于 Linux 平台，随后由 Apple 公司进行修改，从而支持苹果机和 Windows。有关详情，请参阅 [webkit.org](http://webkit.org/)。

#### 主流程

渲染引擎一开始会从网络层获取请求文档的内容，内容的大小一般限制在 8kb 的块以内。然后进行如下所示的基本流程：

![渲染引擎的基本流程](https://github.com/tzstone/MarkdownPhotos/raw/master/%E5%91%88%E7%8E%B0%E5%BC%95%E6%93%8E%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B.png)

渲染引擎将开始解析 HTML 文档，并将各标记逐个转化成“`内容树(content tree)`”上的 DOM 节点。同时也会解析外部 CSS 文件以及样式元素中的样式数据。HTML 中这些带有视觉指令的样式信息将用于创建另一个树结构：[渲染树(render tree)](https://www.html5rocks.com/en/tutorials/internals/howbrowserswork/#Render_tree_construction)。

渲染树包含多个带有视觉属性（如颜色和尺寸）的矩形。这些矩形的排列顺序就是它们将在屏幕上显示的顺序。

渲染树构建完毕之后，进入“`布局(layout)`”处理阶段，也就是为每个节点分配一个应出现在屏幕上的确切坐标。下一个阶段是`绘制(painting)` - 渲染引擎会遍历渲染树，由用户界面后端层(UI backend layer)将每个节点绘制出来。

需要着重指出的是，这是一个渐进的过程。为达到更好的用户体验，渲染引擎会力求尽快将内容显示在屏幕上。它不必等到整个 HTML 文档解析完毕之后，就会开始构建渲染树和设置布局。在不断接收和处理来自网络的其余内容的同时，渲染引擎会将部分内容解析并显示出来。

WebKit 主流程:
![WebKit 主流程](https://github.com/tzstone/MarkdownPhotos/raw/master/webkitflow.png)

Mozilla 的 Gecko 渲染引擎主流程:
![Mozilla 的 Gecko 渲染引擎主流程](https://github.com/tzstone/MarkdownPhotos/raw/master/Mozilla%20%E7%9A%84%20Gecko%20%E5%91%88%E7%8E%B0%E5%BC%95%E6%93%8E%E4%B8%BB%E6%B5%81%E7%A8%8B.jpg)

可以看出，虽然 WebKit 和 Gecko 使用的术语略有不同，但整体流程是基本相同的。Gecko 将视觉格式化元素组成的树称为“`框架树(Frame tree)`”。每个元素都是一个框架。WebKit 使用的术语是“`渲染树(Render Tree)`”，它由“渲染对象(Render Objects)”组成。对于元素的放置，WebKit 使用的术语是“`布局(layout)`”，而 Gecko 称之为“`重排(Reflow)`”。对于连接 DOM 节点和可视化信息从而创建渲染树的过程，WebKit 使用的术语是“附加(Attachment)”。有一个细微的非语义差别，就是 Gecko 在 HTML 与 DOM 树之间还有一个称为“内容槽(content sink)”的层，用于生成 DOM 元素。

## 进程与线程

进程可以被描述为是一个应用的执行程序。线程存在于进程并执行程序任意部分。启动应用时会创建一个进程。程序也许会创建一个或多个线程来帮助它工作，这是可选的。操作系统为进程提供了一个可以使用的“一块”内存，所有应用程序状态都保存在该私有内存空间中。关闭应用程序时，相应的进程也会消失，操作系统会释放内存。

![Process and Thread](https://github.com/tzstone/MarkdownPhotos/raw/master/Process%20and%20Thread.png)

进程可以请求操作系统启动另一个进程来执行不同的任务。此时，内存中的不同部分会分给新进程。如果两个进程需要对话，他们可以通过`进程间通信（IPC）`来进行。许多应用都是这样设计的，所以如果一个工作进程失去响应，该进程就可以在不停止应用程序不同部分的其他进程运行的情况下重新启动。

![IPC](https://github.com/tzstone/MarkdownPhotos/raw/master/workerprocess.svg)

### chrome 的多进程架构:

![不同进程指向浏览器 UI 的不同部分](https://github.com/tzstone/MarkdownPhotos/raw/master/%E4%B8%8D%E5%90%8C%E8%BF%9B%E7%A8%8B%E6%8C%87%E5%90%91%E6%B5%8F%E8%A7%88%E5%99%A8%20UI%20%E7%9A%84%E4%B8%8D%E5%90%8C%E9%83%A8%E5%88%86.png)

#### `浏览器进程`

- 控制应用中的 “Chrome” 部分，包括地址栏，书签，回退与前进按钮。以及处理 web 浏览器不可见的特权部分，如网络请求与文件访问。
- 包含绘制浏览器按钮和输入栏的 `UI 线程`、处理网络栈以从因特网获取数据的`网络线程`、控制文件访问的`存储线程`等

![顶部是浏览器 UI，底部是拥有 UI、网络和存储线程的浏览器进程图](https://github.com/tzstone/MarkdownPhotos/raw/master/%E9%A1%B6%E9%83%A8%E6%98%AF%E6%B5%8F%E8%A7%88%E5%99%A8%20UI%EF%BC%8C%E5%BA%95%E9%83%A8%E6%98%AF%E6%8B%A5%E6%9C%89%20UI%E3%80%81%E7%BD%91%E7%BB%9C%E5%92%8C%E5%AD%98%E5%82%A8%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BF%9B%E7%A8%8B%E5%9B%BE.png)

#### `渲染进程`

- 控制标签页内网站展示。每个标签页都拥有自己独立的渲染进程。

#### `插件进程`

- 控制站点使用的任意插件，如 Flash。

#### `GPU 进程`

- 处理独立于其它进程的 GPU (图形处理器)任务。GPU 被分成不同进程，因为 GPU 处理来自多个不同应用的请求并绘制在相同表面。

## 导航过程(以 chrome 为例)

从浏览器进程开始:

1. 开始导航

   当用户在地址栏输入 URL, 并按下 Enter 键时，`UI 线程`启用网络调取去获取站点内容。加载动画会显示在标签页的一角，`网络线程`会通过适当的协议，像 `DNS 查找`和为请求`建立 TLS 连接`。

   在这时，`网络线程`可能会收到像 HTTP 301 那样的服务器重定向头。这种情况下，`网络线程`会告诉 `UI 线程`，服务器正在请求重定向。然后，另一个 URL 请求会被启动。

2. 读取响应

   ![包含 Content-Type 的响应头以及作为实际数据的 payload](https://github.com/tzstone/MarkdownPhotos/raw/master/%E5%8C%85%E5%90%AB%20Content-Type%20%E7%9A%84%E5%93%8D%E5%BA%94%E5%A4%B4%E4%BB%A5%E5%8F%8A%E4%BD%9C%E4%B8%BA%E5%AE%9E%E9%99%85%E6%95%B0%E6%8D%AE%E7%9A%84%20payload.png)

   一旦开始收到响应主体（payload），`网络线程`会在必要时查看数据流的前几个字节。响应报文的 `Content-Type` 字段会声明数据的类型，但是它有可能会丢失或者错误，所以就有了 MIME 类型嗅探来解决这个问题。

   如果响应是一个 HTML 文件，那么下一步就会把数据传给渲染进程，但是如果是一个压缩文件或是其他文件，那么意味着它是一个下载请求，因此需要将数据传递给下载管理器。

   此时也会进行 `SafeBrowsing` 检查。如果域名和响应数据似乎匹配到一个已知的恶意网站，那么网络线程会显示一个警告页面。除此之外，还会发生 `Cross Origin Read Blocking（CORB）`检查，以确保敏感的跨域数据不被传给渲染进程。

3. 查找渲染进程

   一旦所有的检查执行完毕并且`网络线程`确信浏览器会导航到请求的站点，`网络线程`会告诉 `UI 线程`所有的数据准备完毕。`UI 线程`会寻找`渲染进程`去开始渲染 web 页面。

   由于网络请求会花费几百毫秒才获取回响应，因此可以应用一个优化措施。当第 2 步 `UI 线程`正发送一个 URL 请求给`网络线程`时，它已经知道它们会导航到哪个站点。在网络请求的同时，`UI 线程`并行地尝试主动寻找或开启一个`渲染进程`。这样，如果一切按预期进行，`渲染进程`在`网络线程`接受到数据时就已经处于待命状态。如果导航跨域重定向，这个待命进程也许不会被用到，这种情况下也许会用到另一个进程。

4. 提交导航

   现在数据和渲染进程已经就绪，`浏览器进程`会发送一个 IPC（进程间通信）到`渲染进程`去提交导航。它也会传递数据流，所以`渲染进程`可以保持接收 HTML 数据。一旦浏览器进程收到渲染进程已经提交的确认消息，导航完毕并且文档加载解析开始。

   这时，地址栏已经更新，安全指示器和站点设置 UI 会反映新页面的站点信息。此标签页的 session 历史记录会被更新，所以前进/后退按钮会走向刚导航过的站点。当你关闭标签页或者窗口，为了优化 tab/session 的还原，session 历史被保存在硬盘上。

   ![浏览器和渲染进程间的 IPC，请求渲染页面](https://github.com/tzstone/MarkdownPhotos/raw/master/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%92%8C%E6%B8%B2%E6%9F%93%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%20IPC%EF%BC%8C%E8%AF%B7%E6%B1%82%E6%B8%B2%E6%9F%93%E9%A1%B5%E9%9D%A2.png)

5. 初始加载完毕

   一旦导航被提交，`渲染进程`开始加载资源和渲染页面。一旦渲染进程渲染“结束”。它会发送一个 IPC 返回给`浏览器进程`（这会在页面所有的 frame 的 `onload` 事件已经触发并且执行完毕后发生）。这时，`UI 线程`停止标签页上的加载动画。

   我之所以说“结束”，是因为客户端 JavaScript 可以在这时之后仍然加载额外的资源并且渲染新视图。

   ![渲染进程发送 IPC 到浏览器进程通知页面“已被加载”](https://github.com/tzstone/MarkdownPhotos/raw/master/%E6%B8%B2%E6%9F%93%E8%BF%9B%E7%A8%8B%E5%8F%91%E9%80%81%20IPC%20%E5%88%B0%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BF%9B%E7%A8%8B%E9%80%9A%E7%9F%A5%E9%A1%B5%E9%9D%A2%E2%80%9C%E5%B7%B2%E8%A2%AB%E5%8A%A0%E8%BD%BD%E2%80%9D.png)

6. 导航到另一个站点:

   当用户在地址栏输入另一个 URL 会怎样呢？浏览器进程会执行相同的步骤来导航到一个不同的站点。但是在它做这个之前，它会检查当前已经渲染的站点是否关心 `beforeunload` 事件。

   `beforeunload` 可以在你试图导航离开或关闭标签页时创建“离开此站点？”警告。包括你的 JavaScript 代码，所有标签页内的东西都是由`渲染进程`处理，所以当新的导航请求到来时，`浏览器进程`必须要跟当前的`渲染进程`核对。

   注意： 不要添加无条件的 `beforeunload` 处理程序。它会产生更多`延迟`，因为处理程序需要在导航开始之前执行。应仅在需要时添加此事件处理程序，例如如果需要警告用户他们可能会丢失他们在页面上输入的数据。

   ![浏览器进程向渲染进程发送 IPC 告诉它将要导航到另一个站点](https://github.com/tzstone/MarkdownPhotos/raw/master/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BF%9B%E7%A8%8B%E5%90%91%E6%B8%B2%E6%9F%93%E8%BF%9B%E7%A8%8B%E5%8F%91%E9%80%81%20IPC%20%E5%91%8A%E8%AF%89%E5%AE%83%E5%B0%86%E8%A6%81%E5%AF%BC%E8%88%AA%E5%88%B0%E5%8F%A6%E4%B8%80%E4%B8%AA%E7%AB%99%E7%82%B9.png)

   如果渲染进程已经启动了导航（像用户点击一个链接或者客户端 JavaScript 运行 `window.location = "https://newsite.com"`），渲染进程会先检查 `beforeunload` 事件处理程序。然后，它会像浏览器处理启动导航一样执行相同的步骤。唯一不同的是导航请求是由`渲染进程`发送到`浏览器进程`的。

   当新导航到的站点不同于当前已渲染的站点时，会调用一个独立的渲染进程来处理新导航，同时保持当前的渲染进程来处理类似 `unload` 的事件。

   ![2 个 IPC（从浏览器进程到新渲染进程）告知渲染页面并告知旧渲染进程卸载](https://github.com/tzstone/MarkdownPhotos/raw/master/2%20%E4%B8%AA%20IPC%EF%BC%88%E4%BB%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BF%9B%E7%A8%8B%E5%88%B0%E6%96%B0%E6%B8%B2%E6%9F%93%E8%BF%9B%E7%A8%8B%EF%BC%89%E5%91%8A%E7%9F%A5%E6%B8%B2%E6%9F%93%E9%A1%B5%E9%9D%A2%E5%B9%B6%E5%91%8A%E7%9F%A5%E6%97%A7%E6%B8%B2%E6%9F%93%E8%BF%9B%E7%A8%8B%E5%8D%B8%E8%BD%BD.png)

### `Service Worker`:

service worker 是一种在你的应用代码中编写网络代理的方法；允许 Web 开发者更好地控制本地缓存内容以及何时从网络获取新数据。如果将 service worker 设置为从缓存加载页面，则无需从网络请求数据。Service Worker 是在`渲染进程`中运行的 JavaScript 代码。但是当导航请求进入时，浏览器进程如何知道该站点有 service worker？

当注册一个 service worker 时，保持 service worker 的`作用域`作为一个引用（你可以在这篇文章 [The Service Worker Lifecycle](https://developers.google.com/web/fundamentals/primers/service-workers/lifecycle) 中阅读更多关于作用域的知识）。当一个导航发生时，`网络线程`用已注册的 service worker 作用域来检查域名，如果已经为该 URL 注册了一个 service worker，`UI 线程`会找一个`渲染线程`来执行 service worker 的代码。service worker 可能从缓存中加载数据，无需从网络请求数据，或者可以从网络请求新资源。

![浏览器进程中的网络线程查找 service worker 作用域](https://github.com/tzstone/MarkdownPhotos/raw/master/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BF%9B%E7%A8%8B%E4%B8%AD%E7%9A%84%E7%BD%91%E7%BB%9C%E7%BA%BF%E7%A8%8B%E6%9F%A5%E6%89%BE%20service%20worker%20%E4%BD%9C%E7%94%A8%E5%9F%9F.png)

![浏览器中的 UI 线程启动渲染进程来处理 service workers；然后，渲染进程中的工作线程从网络请求数据](https://github.com/tzstone/MarkdownPhotos/raw/master/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84%20UI%20%E7%BA%BF%E7%A8%8B%E5%90%AF%E5%8A%A8%E6%B8%B2%E6%9F%93%E8%BF%9B%E7%A8%8B%E6%9D%A5%E5%A4%84%E7%90%86%20service%20workers%EF%BC%9B%E7%84%B6%E5%90%8E%EF%BC%8C%E6%B8%B2%E6%9F%93%E8%BF%9B%E7%A8%8B%E4%B8%AD%E7%9A%84%E5%B7%A5%E4%BD%9C%E7%BA%BF%E7%A8%8B%E4%BB%8E%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E6%95%B0%E6%8D%AE.png)

如果 service worker 最终决定从网络请求数据，则浏览器进程和渲染器进程之间的往返可能会导致延迟。`导航预加载`是一种通过与 service worker 启动并行加载资源来加速此过程的机制。它用一个头部来标记这些请求，允许服务器决定为这些请求发送不同的内容；例如，只更新数据而不是完整文档。

![浏览器进程中的 UI 线程启动渲染进程以在并行启动网络请求的同时处理 service worker](https://github.com/tzstone/MarkdownPhotos/raw/master/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BF%9B%E7%A8%8B%E4%B8%AD%E7%9A%84%20UI%20%E7%BA%BF%E7%A8%8B%E5%90%AF%E5%8A%A8%E6%B8%B2%E6%9F%93%E8%BF%9B%E7%A8%8B%E4%BB%A5%E5%9C%A8%E5%B9%B6%E8%A1%8C%E5%90%AF%E5%8A%A8%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E7%9A%84%E5%90%8C%E6%97%B6%E5%A4%84%E7%90%86%20service%20worker.png)

## 渲染过程(以 chrome 为例)

渲染进程负责标签页内发生的所有事情。渲染进程内部包含`主线程`、`工作线程`、`合成线程`和`光栅线程`。在渲染进程中，`主线程`处理服务器发送到用户的大部分代码。如果你使用 web worker 或 service worker，部分 JavaScript 将由`工作线程(worker threads)`处理。`合成`和`光栅线程`也在渲染进程内运行，以高效，流畅地呈现页面。渲染进程的核心工作是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页。

![渲染进程内部包含主线程、工作线程、合成线程和光栅线程](https://github.com/tzstone/MarkdownPhotos/raw/master/%E6%B8%B2%E6%9F%93%E8%BF%9B%E7%A8%8B%E5%86%85%E9%83%A8%E5%8C%85%E5%90%AB%E4%B8%BB%E7%BA%BF%E7%A8%8B%E3%80%81%E5%B7%A5%E4%BD%9C%E7%BA%BF%E7%A8%8B%E3%80%81%E5%90%88%E6%88%90%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%85%89%E6%A0%85%E7%BA%BF%E7%A8%8B.png)

chrome 渲染引擎 webkit 的主流程:
![WebKit 主流程](https://github.com/tzstone/MarkdownPhotos/raw/master/webkitflow.png)

### 解析（Parsing）

解析的过程可以分成两个子过程：`词法分析`和`语法分析`。

`词法分析`是将输入内容分割成大量标记(token)的过程。标记是语言中的词汇，即构成内容的单位。在人类语言中，它相当于语言字典中的单词。

`语法分析`是应用语言的语法规则的过程。

- DOM 的构建

  当渲染进程收到导航的提交消息并开始接收 HTML 数据时，`主线程`开始解析文本字符串（HTML）并将其转换为`文档对象模型（DOM）`。DOM 是一个页面在浏览器内部表现，也是 Web 开发人员可以通过 JavaScript 与之交互的数据结构和 API。

  将 HTML 到 DOM 的解析由 [HTML Standard](https://html.spec.whatwg.org/) 规定。你可能已经注意到，将 HTML 提供给浏览器这一过程从不会引发错误。像 `Hi! <b>I'm <i>Chrome</b>!</i> `这样的错误标记，会被理解为 `Hi! <b>I'm <i>Chrome</i></b><i>!</i>`，这是因为 HTML 规范会优雅地处理这些错误。

  ![主线程解析 HTML 并构建 DOM 树](https://github.com/tzstone/MarkdownPhotos/raw/master/%E4%B8%BB%E7%BA%BF%E7%A8%8B%E8%A7%A3%E6%9E%90%20HTML%20%E5%B9%B6%E6%9E%84%E5%BB%BA%20DOM%20%E6%A0%91.png)

- 子资源加载

  网站通常使用图像、CSS 和 JavaScript 等外部资源，这些文件需要从网络或缓存加载。在解析构建 DOM 时，`主线程`会按处理顺序逐个请求它们(one by one as they find them)，但为了加快速度，“`预加载扫描器（preload scanner）`”会同时运行。如果 HTML 文档中有 `<img>` 或 `<link>` 之类的内容，则预加载扫描器会查看由 HTML 解析器生成的标记(tokens)，并在`浏览器进程`中向`网络线程`发送请求。

  当 HTML 解析器遇到 `<script>` 标记时，会`暂停解析` HTML 文档，开始加载、解析并执行 JavaScript 代码。为什么？因为 JavaScript 可以使用诸如 `document.write()` 的方法来改写文档，这会改变整个 DOM 结构（HTML 规范里的 [overview of the parsing model](https://html.spec.whatwg.org/multipage/parsing.html#overview-of-the-parsing-model) 中有一张不错的图片）。这就是 HTML 解析器必须等待 JavaScript 运行后再继续解析 HTML 文档原因。

  Web 开发者可以通过多种方式向浏览器发送提示，以便很好地加载资源。如果你的 JavaScript 不使用 `document.write()`，你可以在 `<script>` 标签添加 `async` 或 `defer` 属性，这样浏览器会异步加载运行 JavaScript 代码，而不阻塞解析。如果合适，你也可以使用 [JavaScript 模块](https://developers.google.com/web/fundamentals/primers/modules)。可以使用 `<link rel="preload">` 告知浏览器当前导航肯定需要该资源，并且你希望尽快下载。有关详细信息请参阅 [Resource Prioritization – Getting the Browser to Help You](https://developers.google.com/web/fundamentals/performance/resource-prioritization)。

- 预解析

  WebKit 和 Firefox 都进行了这项优化。在执行脚本时，其他线程会解析文档的其余部分，找出并加载需要通过网络加载的其他资源。通过这种方式，资源可以在并行连接上加载，从而提高总体速度。请注意，预解析器不会修改 DOM 树，而是将这项工作交由主解析器处理；预解析器只会解析外部资源（例如外部脚本、样式表和图片）的引用。

- CSS 解析

  理论上来说，应用样式表不会更改 DOM 树，因此似乎没有必要等待样式表并停止文档解析。但这涉及到一个问题，就是脚本在文档解析阶段会请求样式信息。如果当时还没有加载和解析样式，脚本就会获得错误的回复，这样显然会产生很多问题。这看上去是一个非典型案例，但事实上非常普遍。Firefox 在样式表加载和解析的过程中，会禁止所有脚本。而对于 WebKit 而言，仅当脚本尝试访问的样式属性可能受尚未加载的样式表影响时，它才会禁止该脚本。

  ![解析 CSS](https://github.com/tzstone/MarkdownPhotos/raw/master/%E8%A7%A3%E6%9E%90%20CSS.png)

### 渲染树(render tree)构建

在 DOM 树构建的同时，浏览器还会构建另一个树结构：`渲染树`。这是由可视化元素按照其显示顺序而组成的树，也是文档的可视化表示。它的作用是让您按照正确的顺序绘制内容。

- 渲染器(renderers)是和 DOM 元素相对应的，但并非一一对应。非可视化的 DOM 元素不会插入渲染树中，例如“head”元素。如果元素的 display 属性值为“none”，那么也不会显示在渲染树中（但是 visibility 属性值为“hidden”的元素仍会显示）。

  有一些 DOM 元素对应多个可视化对象。它们往往是具有复杂结构的元素，无法用单一的矩形来描述。例如，“select”元素有 3 个渲染器：一个用于显示区域，一个用于下拉列表框，还有一个用于按钮。如果由于宽度不够，文本无法在一行中显示而分为多行，那么新的行也会作为新的渲染器而添加。

  另一个关于多渲染器的例子是格式无效的 HTML。根据 CSS 规范，inline 元素只能包含 block 元素或 inline 元素中的一种。如果出现了混合内容，则应创建匿名的 block 渲染器，以包裹 inline 元素。

  有一些渲染对象对应于 DOM 节点，但在树中所在的位置与 DOM 节点不同。浮动定位和绝对定位的元素就是这样，它们处于正常的流程之外，放置在树中的其他地方，并映射到真正的框架(frame)，而放在原位的是占位框架。

  渲染树及其对应的 DOM 树:
  ![渲染树及其对应的 DOM 树](https://github.com/tzstone/MarkdownPhotos/raw/master/%E6%B8%B2%E6%9F%93%E6%A0%91%E5%8F%8A%E5%85%B6%E5%AF%B9%E5%BA%94%E7%9A%84%20DOM%20%E6%A0%91.png)

- 构建流程

  在 Firefox 中，系统会针对 DOM 更新注册展示层，作为侦听器。展示层将框架创建工作委托给 FrameConstructor，由该构造器解析样式（请参阅样式计算）并创建框架。

  在 WebKit 中，解析样式和创建渲染器的过程称为“附加(attachment)”。每个 DOM 节点都有一个“attach”方法。附加是同步进行的，将节点插入 DOM 树需要调用新的节点“attach”方法。

  处理 html 和 body 标记就会构建渲染树根节点。这个根节点渲染对象对应于 CSS 规范中所说的容器 block，这是最上层的 block，包含了其他所有 block。它的尺寸就是视口，即浏览器窗口显示区域的尺寸。Firefox 称之为 ViewPortFrame，而 WebKit 称之为 RenderView。这就是文档所指向的渲染对象。渲染树的其余部分以 DOM 树节点插入的形式来构建。

  ![渲染树构建](https://github.com/tzstone/MarkdownPhotos/raw/master/%E6%B8%B2%E6%9F%93%E6%A0%91%E6%9E%84%E5%BB%BA.png)

### 样式计算

构建渲染树时，需要计算每一个渲染对象的可视化属性。这是通过计算每个元素的样式属性来完成的。

样式包括来自各种来源的样式表、inline 样式元素和 HTML 中的可视化属性（例如“bgcolor”属性）。其中后者将经过转化以匹配 CSS 样式属性。样式表的来源包括浏览器的默认样式表、由网页作者提供的样式表以及由浏览器用户提供的用户样式表。

- 样式表层叠顺序

  某个样式属性的声明可能会出现在多个样式表中，也可能在同一个样式表中出现多次。这意味着应用规则的顺序极为重要。这称为“层叠”顺序。根据 CSS2 规范，层叠的顺序为（优先级从低到高）：

  1. 浏览器声明
  2. 用户普通声明
  3. 作者普通声明
  4. 作者重要声明
  5. 用户重要声明

  浏览器声明是重要程度最低的，而用户只有将该声明标记为“重要”才可以替换网页作者的声明。同样顺序的声明会根据`特异性`进行排序，然后再是其指定顺序。HTML 可视化属性会转换成匹配的 CSS 声明。它们被视为低优先级的网页作者规则。

- 特异性(Specificity)

  选择器的特异性由 [CSS2](http://www.w3.org/TR/CSS2/cascade.html#specificity) 规范定义如下：

  - 如果声明来自于“style”属性，而不是带有选择器的规则，则记为 1，否则记为 0 (= a)
  - 记为选择器中 ID 属性的个数 (= b)
  - 记为选择器中其他属性和伪类的个数 (= c)
  - 记为选择器中元素名称和伪元素的个数 (= d)

  将四个数字按 a-b-c-d 这样连接起来（位于大数进制的数字系统中），构成特异性。您使用的`进制`取决于上述类别中的最高计数。例如，如果 a=14，您可以使用十六进制。如果 a=17，那么您需要使用十七进制；当然不太可能出现这种情况，除非是存在如下的选择器：html body div div p ...（在选择器中出现了 17 个标记，这样的可能性极低）。

  一些示例：

  ```css
  *             {}  /* a=0 b=0 c=0 d=0 -> specificity = 0,0,0,0 */
  li            {}  /* a=0 b=0 c=0 d=1 -> specificity = 0,0,0,1 */
  li:first-line {}  /* a=0 b=0 c=0 d=2 -> specificity = 0,0,0,2 */
  ul li         {}  /* a=0 b=0 c=0 d=2 -> specificity = 0,0,0,2 */
  ul ol+li      {}  /* a=0 b=0 c=0 d=3 -> specificity = 0,0,0,3 */
  h1 + *[rel=up]{}  /* a=0 b=0 c=1 d=1 -> specificity = 0,0,1,1 */
  ul ol li.red  {}  /* a=0 b=0 c=1 d=3 -> specificity = 0,0,1,3 */
  li.red.level  {}  /* a=0 b=0 c=2 d=1 -> specificity = 0,0,2,1 */
  #x34y         {}  /* a=0 b=1 c=0 d=0 -> specificity = 0,1,0,0 */
  style=""          /* a=1 b=0 c=0 d=0 -> specificity = 1,0,0,0 */
  ```

主线程解析 CSS 并确定每个 DOM 节点计算后的样式:
![主线程解析 CSS 以添加计算后样式](https://github.com/tzstone/MarkdownPhotos/raw/master/%E4%B8%BB%E7%BA%BF%E7%A8%8B%E8%A7%A3%E6%9E%90%20CSS%20%E4%BB%A5%E6%B7%BB%E5%8A%A0%E8%AE%A1%E7%AE%97%E5%90%8E%E6%A0%B7%E5%BC%8F.png)

### 布局

- 现在，渲染进程知道文档的结构和每个节点的样式(渲染树不包含位置和大小信息)，但这不足以渲染页面。布局是计算元素`几何形状`的过程。主线程遍历 DOM，计算样式并创建`布局树(layout tree)`。布局树包含 `x y 坐标`和`边界框大小(bounding box sizes)`等信息。布局树可能与 DOM 树结构类似，但它仅包含页面上`可见内容`相关的信息。如果一个元素应用了 `display：none`，那么该元素不是布局树的一部分（但 `visibility：hidden` 的元素在布局树中）。类似地，如果应用了如 `p::before{content:"Hi!"}` 的伪类，则即使它不在 DOM 中，也包含于布局树中。

- HTML 采用基于流的布局模型，这意味着大多数情况下只要一次遍历就能计算出几何信息。处于流中靠后位置元素通常不会影响靠前位置元素的几何特征，因此布局可以按从左至右、从上至下的顺序遍历文档。但是也有例外情况，比如 HTML 表格的计算就需要不止一次的遍历 。

  坐标系是相对于根框架而建立的，使用的是上坐标和左坐标。

  布局是一个递归的过程。它从根渲染器（对应于 HTML 文档的 `<html>` 元素）开始，然后递归遍历部分或所有的框架层次结构，为每一个需要计算的渲染器计算几何信息。

  根渲染器的位置左边是 0,0，其尺寸为视口（也就是浏览器窗口的可见区域）。
  所有的渲染器都有一个“layout”或者“reflow”方法，每一个渲染器都会调用其需要进行布局的子代的 layout 方法。

- Dirty 位系统

  为避免对所有细小更改都进行整体布局，浏览器采用了一种“dirty 位”系统。如果某个渲染器发生了更改，或者将自身及其子代标注为“dirty”，则需要进行布局。

  有两种标记：“dirty”和“children are dirty”。“children are dirty”表示尽管渲染器自身没有变化，但它至少有一个子代需要布局。

- `全局布局`和`增量布局`

  全局布局是指触发了整个渲染树范围的布局，触发原因可能包括：

  - 影响所有渲染器的全局样式更改，例如字体大小更改。
  - 屏幕大小调整(resize)。

  布局可以采用增量方式，也就是只对 dirty 渲染器进行布局（这样可能存在需要进行额外布局的弊端）。当渲染器为 dirty 时，会异步触发增量布局。例如，当来自网络的额外内容添加到 DOM 树之后，新的渲染器附加到了渲染树中。

  增量布局 - 只有 dirty 渲染器及其子代进行布局:
  ![增量布局 - 只有 dirty 渲染器及其子代进行布局](https://github.com/tzstone/MarkdownPhotos/raw/master/reflow.png)

- `异步布局`和`同步布局`

  `增量布局`是`异步执行`的。Firefox 将增量布局的“reflow 命令”加入队列，而调度程序会触发这些命令的批量执行。WebKit 也有用于执行增量布局的计时器：对渲染树进行遍历，并对 dirty 渲染器进行布局。

  请求样式信息, 例如 offset(Top/Left/Width/Height), scroll(Top/Left/Width/Height), cilent(Top/Left/Width/Height), getComputedStyle()或者 IE 的 currentStyle）的脚本可`同步触发增量布局`。

  `全局布局`往往是`同步触发`的。

  有时，当初始布局完成之后，如果一些属性（如滚动位置）发生变化，布局就会作为回调而触发。

- 优化

  如果布局是由“大小调整(resize)”或渲染器的位置（而非大小）改变而触发的，那么可以从缓存中获取渲染器的大小，而无需重新计算。
  在某些情况下，只有一个子树进行了修改，因此无需从根节点开始布局。这适用于在本地进行更改而不影响周围元素的情况，例如在文本字段中插入文本（否则每次键盘输入都将触发从根节点开始的布局）。

- 布局处理

  布局通常具有以下模式：

  1. 父渲染器确定自己的宽度。
  2. 父渲染器依次处理子渲染器，并且：

     1. 放置子渲染器（设置 x,y 坐标）。
     2. 如果有必要，调用子渲染器的布局（如果子渲染器是 dirty 的，或者这是全局布局，或出于其他某些原因），这会计算子渲染器的高度。

  3. 父渲染器根据子渲染器的累加高度以及边距和补白的高度来设置自身高度，此值也可供父渲染器的父渲染器使用。
  4. 将其 dirty 位设置为 false。

- 宽度计算

  渲染器宽度是根据容器(container)块的宽度、渲染器样式中的“width”属性以及边距和边框计算得出的。例如以下 div 的宽度：

  ```html
  <div style="width:30%" />
  ```

  将由 WebKit 计算如下（BenderBox 类，calcWidth 方法）：

  - 容器的宽度取容器的 availableWidth 和 0 中的较大值。availableWidth 在本例中相当于 contentWidth，计算公式如下：

  ```javascript
  clientWidth() - paddingLeft() - paddingRight();
  ```

  clientWidth 和 clientHeight 表示一个对象的内部（除去边框和滚动条）。

  - 元素的宽度是“width”样式属性。它会根据容器宽度的百分比计算得出一个绝对值。
  - 然后加上水平方向的边框和补白。

  现在计算得出的是“preferred width”。然后需要计算最小宽度和最大宽度。如果首选宽度大于最大宽度，那么应使用最大宽度。如果首选宽度小于最小宽度（最小的不可破开单位），那么应使用最小宽度。

  这些值会缓存起来，以用于需要布局而宽度不变的情况。

- 换行

  如果渲染器在布局过程中需要换行，会立即停止布局，并告知其父代需要换行。父代会创建额外的渲染器，并对其调用布局。

主线程遍历计算样式后的 DOM 树，以此生成布局树:

![主线程遍历计算样式后的 DOM 树，以此生成布局树](https://github.com/tzstone/MarkdownPhotos/raw/master/%E4%B8%BB%E7%BA%BF%E7%A8%8B%E9%81%8D%E5%8E%86%E8%AE%A1%E7%AE%97%E6%A0%B7%E5%BC%8F%E5%90%8E%E7%9A%84%20DOM%20%E6%A0%91%EF%BC%8C%E4%BB%A5%E6%AD%A4%E7%94%9F%E6%88%90%E5%B8%83%E5%B1%80%E6%A0%91.png)

### 绘制

- 拥有 DOM、样式和布局仍然不足以渲染页面。假设你正在尝试重现一幅画。你知道元素的大小、形状和位置，但你仍需要判断绘制它们的`顺序`。例如，可以为某些元素设置 `z-index`，此时按 HTML 中编写的元素的顺序绘制会导致错误的渲染。在绘制步骤中，主线程遍历`布局树(layout tree)`创建`绘制记录(paint records)`。绘制记录是绘图过程的记录，就像是“背景优先，然后是文本，然后是矩形”。如果你使用过 JavaScript 绘制了 `<canvas>` 元素，那么这个过程对你来说可能很熟悉。

  ![主线程遍历布局树并生成绘制记录](https://github.com/tzstone/MarkdownPhotos/raw/master/%E4%B8%BB%E7%BA%BF%E7%A8%8B%E9%81%8D%E5%8E%86%E5%B8%83%E5%B1%80%E6%A0%91%E5%B9%B6%E7%94%9F%E6%88%90%E7%BB%98%E5%88%B6%E8%AE%B0%E5%BD%95.png)

- 更新渲染管道(rendering pipeline)

  ![DOM + Style、布局和绘制树的生成顺序](https://github.com/tzstone/MarkdownPhotos/raw/master/DOM%20%2B%20Style%E3%80%81%E5%B8%83%E5%B1%80%E5%92%8C%E7%BB%98%E5%88%B6%E6%A0%91%E7%9A%84%E7%94%9F%E6%88%90%E9%A1%BA%E5%BA%8F.gif)

  渲染管道中最重要的事情是：每个步骤中，前一个操作的结果都用于创建新数据(style->layout->paint)。例如，如果布局树中的某些内容发生改变，需要为文档的受影响部分重新生成`绘制顺序(paint order)`。

  - 重绘(repaint)与重排(reflow/layout)
    - 重绘意味着元素发生的改变只是影响了元素的一些外观之类的时候（例如，背景色，边框颜色，文字颜色等），此时只需要应用新样式绘制这个元素就可以了
    - 重排，也称为回流，一般意味着元素的内容、结构、位置或尺寸发生了变化，需要重新计算样式和渲染树
    - 回流的成本开销要高于重绘，而且一个节点的回流往往回导致子节点以及同级节点的回流，所以优化方案中一般都包括，尽量避免回流。

  如果要为元素设置动画，则浏览器必须在每个帧之间运行这些操作。大多数显示器每秒刷新屏幕 60 次（60 fps），当屏幕每帧都在变化，人眼会觉得动画很流畅。但是，如果动画丢失了中间一些帧，页面看起来就会卡顿（janky）。

  ![时间轴上的动画帧](https://github.com/tzstone/MarkdownPhotos/raw/master/%E6%97%B6%E9%97%B4%E8%BD%B4%E4%B8%8A%E7%9A%84%E5%8A%A8%E7%94%BB%E5%B8%A7.png)

  即使渲染操作能跟上屏幕刷新，这些计算也会在`主线程`上运行，这意味着当你的应用程序运行 JavaScript 时动画可能会被阻塞。

  ![时间轴上的动画帧，但 JavaScript 阻塞了一帧](https://github.com/tzstone/MarkdownPhotos/raw/master/%E6%97%B6%E9%97%B4%E8%BD%B4%E4%B8%8A%E7%9A%84%E5%8A%A8%E7%94%BB%E5%B8%A7%EF%BC%8C%E4%BD%86%20JavaScript%20%E9%98%BB%E5%A1%9E%E4%BA%86%E4%B8%80%E5%B8%A7.png)

  你可以将 JavaScript 操作划分为小块，并使用 `requestAnimationFrame()` 在每个帧上运行。有关此主题的更多信息，请参阅 [Optimize JavaScript Execution](https://developers.google.com/web/fundamentals/performance/rendering/optimize-javascript-execution)。你也可以在 [Web Worker](https://www.youtube.com/watch?v=X57mh8tKkgE) 中运行 JavaScript 以避免阻塞主线程。

  ![时间轴上较小的 JavaScript 块与动画帧一起运行](https://github.com/tzstone/MarkdownPhotos/raw/master/%E6%97%B6%E9%97%B4%E8%BD%B4%E4%B8%8A%E8%BE%83%E5%B0%8F%E7%9A%84%20JavaScript%20%E5%9D%97%E4%B8%8E%E5%8A%A8%E7%94%BB%E5%B8%A7%E4%B8%80%E8%B5%B7%E8%BF%90%E8%A1%8C.png)

- [全局绘制和增量绘制](https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/)

  和布局一样，绘制也分为全局（绘制整个渲染树）和增量两种。在增量绘制中，部分渲染器发生了更改，但是不会影响整个树。更改后的渲染器将其在屏幕上对应的矩形区域设为无效，这导致 OS 将其视为一块“dirty 区域”，并生成“paint”事件。OS 会很巧妙地将多个区域合并成一个。在 Chrome 浏览器中，情况要更复杂一些，因为 Chrome 浏览器的渲染器不在主进程上。Chrome 浏览器会在某种程度上模拟 OS 的行为。展示层会侦听这些事件，并将消息委托给渲染根节点。然后遍历渲染树，直到找到相关的渲染器，该渲染器会重新绘制自己（通常也包括其子代）。

- 绘制顺序

  [CSS2 规范定义了绘制流程的顺序](http://www.w3.org/TR/CSS21/zindex.html)。绘制的顺序其实就是元素进入[堆栈样式上下文](https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/#stackingcontext)的顺序。这些堆栈会从后往前绘制，因此这样的顺序会影响绘制。块(block)渲染器的堆栈顺序如下：

  1. 背景颜色(background color)
  2. 背景图片(background image)
  3. 边框(border)
  4. 子代(children)
  5. 轮廓(outline)

  堆栈顺序示例:

  ```pre
  The bottom of the stack is the furthest from the user, the top of the stack is the nearest to the user:

  	    |	   |	     |	  |
              |		|    |	  |	⇦ ☻
              |		|	  |	user
  z-index:  canvas  -1	0    1	  2
  ```

- [动态变化](https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/)

  在发生变化时，浏览器会尽可能做出最小的响应。因此，元素的颜色改变后，只会对该元素进行重绘。元素的位置改变后，只会对该元素及其子元素（可能还有同级元素）进行布局和重绘。添加 DOM 节点后，会对该节点进行布局和重绘。一些重大变化（例如增大“html”元素的字体）会导致缓存无效，使得整个渲染树都会进行重新布局和绘制。

### 合成

- 现在浏览器知道文档的结构、每个元素的样式、页面的几何形状和绘制顺序，它是如何绘制页面的？把这些信息转换为屏幕上的`像素`，我们称为`光栅化`。

  处理这种情况的一种简单的方法是，先在光栅化视窗内(viewport)的画面，如果用户滚动页面，则移动光栅框，并光栅化填充缺少的部分。这就是 Chrome 首次发布时处理光栅化的方式。但是，现代浏览器会运行一个更复杂的过程，我们称为合成。

  ![简单光栅处理示意动画](https://github.com/tzstone/MarkdownPhotos/raw/master/%E7%AE%80%E5%8D%95%E5%85%89%E6%A0%85%E5%A4%84%E7%90%86%E7%A4%BA%E6%84%8F%E5%8A%A8%E7%94%BB.gif)

  `合成`是一种将页面的各个部分`分层`，分别`光栅化`，并在称为`合成线程`的单独线程中`合成为页面`的技术。如果发生滚动，由于图层已经光栅化，因此它所要做的只是合成一个新帧。动画也可以以相同的方式（移动图层和合成新帧）实现。

  ![合成处理示意动画](https://github.com/tzstone/MarkdownPhotos/raw/master/%E5%90%88%E6%88%90%E5%A4%84%E7%90%86%E7%A4%BA%E6%84%8F%E5%8A%A8%E7%94%BB.gif)

  你可以在 DevTools 使用 [Layers 面板](https://blog.logrocket.com/eliminate-content-repaints-with-the-new-layers-panel-in-chrome-e2c306d4d752?gi=cd6271834cea) 看看你的网站如何被分层。

- 分层

  为了分清哪些元素位于哪些图层，主线程遍历`布局树(layout tree)`创建`图层树(layer tree)`（此部分在 DevTools 性能面板中称为“Update Layer Tree”）。如果页面的某些部分应该是单独图层（如滑入式侧面菜单）但没拆分出来，你可以使用 CSS 中的 `will-change` 属性来提示浏览器。

  ![主线程遍历布局树生成图层树](https://github.com/tzstone/MarkdownPhotos/raw/master/%E4%B8%BB%E7%BA%BF%E7%A8%8B%E9%81%8D%E5%8E%86%E5%B8%83%E5%B1%80%E6%A0%91%E7%94%9F%E6%88%90%E5%9B%BE%E5%B1%82%E6%A0%91.png)

  你可能想要为每个元素都分层，但是合成大量的图层可能会比每帧都光栅化页面的刷新方式更慢，因此测量应用程序的渲染性能至关重要。有关这个主题的更多信息，请参阅 [Stick to Compositor-Only Properties and Manage Layer Count](https://developers.google.com/web/fundamentals/performance/rendering/stick-to-compositor-only-properties-and-manage-layer-count)。

  - 普通图层
  - 复合图层

    - 普通文档流可以理解为一个默认复合图层

      absolute, fixed 布局可以脱离文档流,但还是属于默认复合图层, 就算 absolute 中信息改变时不会改变普通文档流中 render 树，但是，浏览器最终绘制时，是整个复合层绘制的，所以 absolute 中信息的改变，仍然会影响整个复合层的绘制。（浏览器会重绘它，如果复合层中内容多，absolute 带来的绘制信息变化过大，资源消耗是非常严重的）

    - 创建新的复合图层, 会单独分配资源(会脱离普通文档流, 将复合图层与默认复合图层隔离开来, 不互相影响, 避免改动引起整个页面重绘, 提升性能)

    - 创建复合图层

      - 3D 或透视变换(perspective transform) CSS 属性
      - 使用加速视频解码的`<video>`元素
      - 拥有 3D (WebGL) 上下文或加速的 2D 上下文的 `<canvas>`元素
      - 混合插件(如 Flash)
      - 对自己的 opacity 做 CSS 动画或使用一个动画变换的元素
      - 拥有加速 CSS 过滤器的元素, 如 CSS filters
      - 元素有一个包含复合层的后代节点(换句话说，就是一个元素拥有一个子元素，该子元素在自己的层里)
      - 元素有一个 z-index 较低且包含一个复合层的兄弟元素(换句话说就是该元素在复合层上面渲染)

    - 需要注意的是，如果图层中某个元素需要重绘，那么整个图层都需要重绘。比如一个图层包含很多节点，其中有个 gif 图，gif 图的每一帧，都会重绘整个图层的其他节点，然后生成最终的图层位图。所以这需要通过特殊的方式来强制 gif 图属于自己一个图层（translateZ(0)或者 translate3d(0,0,0)），CSS3 的动画也是一样（好在绝大部分情况浏览器自己会为 CSS3 动画的节点创建图层）

- 主线程的光栅化和合成

  一旦创建了`图层树( layer tree)`并确定了`绘制顺序(paint orders)`，主线程就会将该信息提交给`合成线程`。接着，合成线程会光栅化每个图层。一个图层可能会跟整个页面一样大，因此`合成线程`将它们分块(tiles)后发送到`光栅线程(Raster thread)`。光栅线程光栅化每个小块后会将它们存储在显存(GPU memory)中。

  ![光栅线程创建分块的位图并发送到 GPU](https://github.com/tzstone/MarkdownPhotos/raw/master/%E5%85%89%E6%A0%85%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA%E5%88%86%E5%9D%97%E7%9A%84%E4%BD%8D%E5%9B%BE%E5%B9%B6%E5%8F%91%E9%80%81%E5%88%B0%20GPU.png)

  合成线程(compositor thread)会给不同的光栅线程设置优先级，以便视窗（或附近）内的画面可以先被光栅化。图层还具有多个不同分辨率的块(tilings)，可以处理放大(zoom-in)等操作。

  一旦块(tiles)被光栅化，合成线程会收集这些块的信息（称为`绘制四边形(draw quads)`）来创建`合成帧(compositor frame)`。

  - 绘制四边形

    包含诸如图块在内存中的位置，以及合成时绘制图块在页面中的位置等信息。

  - 合成帧

    一个绘制四边形的集合，代表一个页面的一帧。

  接着，`合成帧`通过 IPC（进程间通讯）提交给`浏览器进程`。此时，可以从 `UI 线程`或其他插件的渲染进程添加另一个合成帧。这些合成器帧被发送到 `GPU` 然后在屏幕上显示。如果接收到滚动事件，合成线程会创建另一个合成帧发送到 GPU。

  ![合成线程创建合成帧，将其发送到浏览器进程，再接着发送到 GPU](https://github.com/tzstone/MarkdownPhotos/raw/master/%E5%90%88%E6%88%90%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA%E5%90%88%E6%88%90%E5%B8%A7%EF%BC%8C%E5%B0%86%E5%85%B6%E5%8F%91%E9%80%81%E5%88%B0%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BF%9B%E7%A8%8B%EF%BC%8C%E5%86%8D%E6%8E%A5%E7%9D%80%E5%8F%91%E9%80%81%E5%88%B0%20GPU.png)

  `合成的好处是它可以在不涉及主线程的情况下完成。合成线程不需要等待样式计算或 JavaScript 执行。`这就是为什么[仅合成动画](https://www.html5rocks.com/en/tutorials/speed/high-performance-animations/)被认为是流畅性能的最佳选择。`如果需要再次计算布局或绘制，则必须涉及主线程。`

## 交互过程(以 chrome 为例)

- 浏览器视角下的输入事件

  浏览器眼中，输入意味着一切用户行为。不单滚动鼠标滑轮是输入事件，触摸屏幕、滑动鼠标同样也是用户输入事件。诸如触摸屏幕之类用户手势产生时，浏览器进程会率先将其捕获。然而浏览器进程所掌握的信息仅限于行为发生的区域，因为标签页里的内容都由渲染进程负责处理，所以`浏览器进程`会将事件类型（如 `touchstart`）及其坐标发送给`渲染进程`。渲染进程会寻至事件目标，运行其事件监听器，妥善地处理事件。

  ![输入事件由浏览器进程发往渲染进程](https://github.com/tzstone/MarkdownPhotos/raw/master/%E8%BE%93%E5%85%A5%E4%BA%8B%E4%BB%B6%E7%94%B1%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BF%9B%E7%A8%8B%E5%8F%91%E5%BE%80%E6%B8%B2%E6%9F%93%E8%BF%9B%E7%A8%8B.png)

- 合成器接收输入事件

  在上篇文章里，我们探讨了合成器如何通过合成栅格化图层，实现流畅的页面滚动。如果页面上没有添加任何事件监听，合成线程会独立于主线程创建一个的新合成帧。但要是页面上添加了事件监听呢？合成线程又是如何得知事件是否需要处理的？

  - 非立即可滚动区

    因为运行 JavaScript 脚本是`主线程`的工作，所以页面合成后，合成线程会将页面里添加了`事件监听`的区域标记为“`非立即可滚动区(Non-Fast Scrollable Region)`”。有了这个信息，如果输入事件发生在这一区域，合成线程可以确定应将其发往主线程处理。如输入事件发生在这一区域之外，合成线程则确定无需等待主线程，可继续合成新帧。

    ![非立即可滚动区输入描述示意图](https://github.com/tzstone/MarkdownPhotos/raw/master/%E9%9D%9E%E7%AB%8B%E5%8D%B3%E5%8F%AF%E6%BB%9A%E5%8A%A8%E5%8C%BA%E8%BE%93%E5%85%A5%E6%8F%8F%E8%BF%B0%E7%A4%BA%E6%84%8F%E5%9B%BE.png)

  - 设置事件处理器时须注意

    web 开发中常用的事件处理模式是事件代理。因为事件会冒泡，所以你可以在最顶层的元素中添加一个事件处理器，用来代理事件目标产生的任务。下面这样的代码，你可能见过，或许也写过。

    ```javascript
    document.body.addEventListener('touchstart', (event) => {
      if (event.target === area) {
        event.preventDefault();
      }
    });
    ```

    这样只需添加一个事件监听器，即可监听所有元素，的确十分省事。然而，如果站在浏览器的角度去考量，这等于把整个页面都标记成了“`非立即可滚动区`”，意味着即便你设计的应用本不必理会页面上一些区域的输入行为，合成线程也必须在每次输入事件产生后与主线程通信并等待返回。如此则得不偿失，使原本能保障页面滚动流畅的合成器没了用武之地。

    ![非立即可滚动区覆盖整个页面下的输入描述示意图](https://github.com/tzstone/MarkdownPhotos/raw/master/%E9%9D%9E%E7%AB%8B%E5%8D%B3%E5%8F%AF%E6%BB%9A%E5%8A%A8%E5%8C%BA%E8%A6%86%E7%9B%96%E6%95%B4%E4%B8%AA%E9%A1%B5%E9%9D%A2%E4%B8%8B%E7%9A%84%E8%BE%93%E5%85%A5%E6%8F%8F%E8%BF%B0%E7%A4%BA%E6%84%8F%E5%9B%BE.png)

    你可以给事件监听添加一个 `passive:true` 选项 ，将这种负面效果最小化。这会提示浏览器你想继续在主线程中监听事件，但合成器不必停滞等候，可接着创建新的合成帧。

    ```javascript
    document.body.addEventListener(
      'touchstart',
      (event) => {
        if (event.target === area) {
          event.preventDefault();
        }
      },
      { passive: true },
    );
    ```

    - passive

      A Boolean that, if true, indicates that the function specified by listener will never call `preventDefault()`

      According to the specification, the default value for the `passive` option is always `false`. However, this introduces the potential for event listeners handling certain touch events (among others) to block the browser's main thread while it is attempting to handle scrolling, resulting in possibly enormous reduction in performance during scroll handling.

      To prevent this problem, some browsers (specifically, Chrome and Firefox) have changed the default value of the `passive` option to `true` for the `touchstart` and `touchmove` events on the document-level nodes `Window`, `Document`, and `Document.body`. This prevents the event listener from being called, so it can't block page rendering while the user is scrolling.

- 检查事件是否可撤销

  ![部分区域仅可水平方向滚动的网页](https://github.com/tzstone/MarkdownPhotos/raw/master/%E9%83%A8%E5%88%86%E5%8C%BA%E5%9F%9F%E4%BB%85%E5%8F%AF%E6%B0%B4%E5%B9%B3%E6%96%B9%E5%90%91%E6%BB%9A%E5%8A%A8%E7%9A%84%E7%BD%91%E9%A1%B5.png)

  设想一下这种情形：页面上有一个盒子，你要将其滚动方向限制为水平滚动。为目标事件设置 `passive:true` 选项可让页面滚动平滑，但在你使用 `preventDefault` 以限制滚动方向时，垂直方向滚动可能已经触发。使用 `event.cancelable` 可以检查并阻止这种情况发生。

  ```javascript
  document.body.addEventListene(
    'pointermove',
    (event) => {
      if (event.cancelable) {
        event.preventDefault(); // 阻止默认的滚动行为
        /*
         *  这里设置程序执行任务
         */
      }
    },
    { passive: true },
  );
  ```

  或者，你也可以应用 `touch-action` 这类 CSS 规则，完全地将事件处理器屏蔽掉。

  ```html
  #area { touch-action: pan-x; }
  ```

- 定位事件目标

  ![主线程检查绘制记录查询坐标 x、y 处绘制内容](https://github.com/tzstone/MarkdownPhotos/raw/master/%E4%B8%BB%E7%BA%BF%E7%A8%8B%E6%A3%80%E6%9F%A5%E7%BB%98%E5%88%B6%E8%AE%B0%E5%BD%95%E6%9F%A5%E8%AF%A2%E5%9D%90%E6%A0%87%20x%E3%80%81y%20%E5%A4%84%E7%BB%98%E5%88%B6%E5%86%85%E5%AE%B9.png)

  合成器将输入事件发送至主线程后，首先运行的是`命中检测(hit test)`。命中检测会使用渲染进程中产生的绘制记录数据，找出事件发生坐标下的内容。

- 降低往主线程发送事件的频率

  之前的文章里，我们探讨了常见显示屏如何以每秒 60 帧的频率刷新，以及我们要怎样与其刷新频率保持步调一致，以营造出流畅的动画效果。而对于用户的输入行为，常见触摸屏设备的事件传输频率为每秒 60~120 次，常见鼠标设备的事件传输频率为每秒 100 次。可见，输入事件有着比显示屏幕更高的保真度。

  如果一连串 `touchmove` 这样的事件以每秒 120 次的频率发送往主线程，那么可能会触发过量的命中检测及 JavaScript 脚本执行。相形而言，我们的屏幕刷新率则低下得多。

  ![大量事件涌入合成帧时间轴会造成页面闪烁](https://github.com/tzstone/MarkdownPhotos/raw/master/%E5%A4%A7%E9%87%8F%E4%BA%8B%E4%BB%B6%E6%B6%8C%E5%85%A5%E5%90%88%E6%88%90%E5%B8%A7%E6%97%B6%E9%97%B4%E8%BD%B4%E4%BC%9A%E9%80%A0%E6%88%90%E9%A1%B5%E9%9D%A2%E9%97%AA%E7%83%81.png)

  为了降低往主线程中传递过量调用，Chrome 会合并(coalesces)这些连续事件（如：`wheel`, `mousewheel`, `mousemove`, `pointermove`, `touchmove` 等），并将其延迟至下一次 `requestAnimationFrame` 前发送。

  ![相同的时间轴下事件被合并且延迟发送](https://github.com/tzstone/MarkdownPhotos/raw/master/%E7%9B%B8%E5%90%8C%E7%9A%84%E6%97%B6%E9%97%B4%E8%BD%B4%E4%B8%8B%E4%BA%8B%E4%BB%B6%E8%A2%AB%E5%90%88%E5%B9%B6%E4%B8%94%E5%BB%B6%E8%BF%9F%E5%8F%91%E9%80%81.png)

  所有独立的事件，如: `keydown`, `keyup`, `mouseup`, `mousedown`, `touchstart`, 及 `touchend` 则会立即发往主线程。

  - 使用 `getCoalescedEvents` 获取帧内事件

    事件合并可帮助大多数 web 应用构建良好的用户体验。然而，如果你开发的是一个绘图类应用，需要基于 `touchmove` 事件的坐标绘制线路，那么在你试图画下一根光滑的线条时，区间内的一些坐标点也可能会因事件合并而丢失。这时，你可以使用目标事件的 `getCoalescedEvents` 方法获取事件合并后的信息。

    ![左为流畅的触摸手势路径、右为事件合并后的有限路径](https://github.com/tzstone/MarkdownPhotos/raw/master/%E5%B7%A6%E4%B8%BA%E6%B5%81%E7%95%85%E7%9A%84%E8%A7%A6%E6%91%B8%E6%89%8B%E5%8A%BF%E8%B7%AF%E5%BE%84%E3%80%81%E5%8F%B3%E4%B8%BA%E4%BA%8B%E4%BB%B6%E5%90%88%E5%B9%B6%E5%90%8E%E7%9A%84%E6%9C%89%E9%99%90%E8%B7%AF%E5%BE%84.png)

    ```javascript
    window.addEventListener('pointermove', (event) => {
      const events = event.getCoalescedEvents();
      for (let event of events) {
        const x = event.pageX;
        const y = event.pageY;
        // 使用 x、y 坐标画线
      }
    });
    ```

### GUI 渲染线程

- 负责渲染浏览器界面，解析 HTML，CSS，构建 DOM 树和 RenderObject 树，布局和绘制等。当界面需要`重绘（Repaint）`或由于某种操作引发`回流(reflow)`时，该线程就会执行。
- 注意，`GUI 渲染线程`与 `JS 引擎线程`是互斥的，当 `JS 引擎`执行时 `GUI 线程`会被挂起（相当于被冻结了），GUI 更新会被保存在一个队列中等到 JS 引擎空闲时立即被执行。

### JS 引擎线程

- `JS 引擎线程`负责解析 Javascript 脚本，运行代码。JS 引擎一直等待着任务队列中任务的到来，然后加以处理，一个 Tab 页（renderer 进程）中无论什么时候都只有一个 JS 线程在运行 JS 程序。
- 同样注意，`GUI 渲染线程`与 `JS 引擎线程`是互斥的，所以如果 JS 执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。

### 事件触发线程

- 归属于浏览器而不是 JS 引擎，用来控制事件循环。当 JS 引擎执行代码块如 setTimeOut 时（也可来自浏览器内核的其他线程,如鼠标点击、AJAX 异步请求等），会将对应任务添加到事件线程中. 当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待 JS 引擎的处理
- 注意，由于 JS 的单线程关系，所以这些待处理队列中的事件都得排队等待 JS 引擎处理（当 JS 引擎空闲时才会去执行）

### 定时器触发线程

- setInterval 与 setTimeout 所在线程。浏览器定时计数器并不是由 JavaScript 引擎计数的,（因为 JavaScript 引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确）. 因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待 JS 引擎空闲后执行）
- 注意，W3C 在 HTML 标准中规定，规定要求 setTimeout 中低于 4ms 的时间间隔算为 4ms。

### 异步 http 请求线程

- 在 XMLHttpRequest 在连接后是通过浏览器新开一个线程请求。当检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由 JavaScript 引擎执行。

## Event Loop

渲染引擎采用了单线程。几乎所有操作（除了网络操作）都是在单线程中进行的。在 Firefox 和 Safari 中，该线程就是浏览器的主线程。而在 Chrome 浏览器中，该线程是标签进程的主线程。
网络操作可由多个并行线程执行。并行连接数是有限的（通常为 2 至 6 个，以 Firefox 3 为例是 6 个）。

浏览器的主线程是事件循环。它是一个无限循环，永远处于接受处理状态，并等待事件（如布局和绘制事件）发生，并进行处理。

参考资料

[How Browsers Work: Behind the Scenes of Modern Web Browsers](https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/)

[Tasks, microtasks, queues and schedules](https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/)

[JavaScript 运行机制详解：再谈 Event Loop](http://www.ruanyifeng.com/blog/2014/10/event-loop.html)

[[译]现代浏览器内部揭秘（第一部分）](https://juejin.cn/post/6844903679389073415)

[[译]现代浏览器内部揭秘（第二部分）](https://juejin.cn/post/6844903692890537992)

[[译]现代浏览器内部揭秘（第三部分）](https://juejin.cn/post/6844903692894732295)

[[译]现代浏览器内部揭秘（第四部分）](https://juejin.cn/post/6844903695600058375)
