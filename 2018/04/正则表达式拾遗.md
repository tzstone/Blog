# 正则表达式拾遗

## 基础

- 括号的作用
  - 限制多选结构的范围
  - 将若干字符组合为一个单元, 受`?`、`*`、`+`等量词的作用
  - 捕获分组.
- "子表达式"指的是整个正则表达式中的一部分, 通常是括号内的表达式, 或者是由`|`分隔的多选分支. 严格来讲, 字符也可以是子表达式, 如`cat`中`c`、`a`、`t`都算子表达式.
- 转义的3种情况
  - `\`加上元字符, 表示匹配元字符所使用的普通字符(如`\*`匹配普通的星号)
  - `\`加上非元字符, 组成一种由具体实现方式规定其意义的元字符序列(如egrep中`\<`表示单词的起始边界)
  - `\`加上任意其他字符, 默认情况就是匹配此字符(反斜杠被忽略了)

## 元字符

- `^`匹配字符串的开始, `$`匹配字符串的结尾.
- `.` 匹配除换行符以外的任意字符
- `|` 多选结构, 可以包括很多字符, 但不能超越括号的界限(如`gr(a|e)y`).
- `\b` 单词分界符. 匹配一个位置, 该位置的一侧是单词, 另一侧不是单词. 单词是指`\w`, 即字母, 数字, 下划线.
- `\B` 非单词分界符
- `\G` (Perl支持)匹配上一次匹配结束的位置, 在第一次迭代时, `\G`匹配字符串的开头.
  - 如果匹配不成功, `\G`的匹配会重新指向字符串的起始位置.
- `\C` 匹配单个字节(Perl和PHP支持), 即使该字节位于某个多字节编码的字符之中(相反, 其他功能都是基于字符的).
- `\t` Tab字符(\u0009)
- `\n` 换行符(\u000A)
- `\v` 垂直制表符(\u000B)
- `\f` 换页符(\u000C)
- `\r` 回车符(\u000D)
- `\cx` 匹配x指示的控制字符, 要求x的值必须在a-z或A-Z范围内
- `\xn` 匹配n, n是一个十六进制转义码
- `\un` 匹配n, n是以四位十六进制数表示的Unicode字符

## 量词

- 量词限定了所作用元素的匹配次数. 量词的每一次迭代分别对所作用的元素进行匹配, 这意味着每次迭代匹配的结果可能不一致.
  - 如`/^(11+){2,}$/.test('11111')`能匹配成功, 此时量词进行了两次迭代, 一次匹配了`111`, 另一次匹配了`11`
- 量词作用的对象是它们之前紧邻的子表达式.
  - 一个字符组是一个"单元(unit)", 所以它后面可以加量词, 如`[0-9]+`
- 量词在正常情况下都是"匹配优先"的, 即匹配尽可能多的内容.
- 忽略优先量词: `*?`、`+?`、`??`、`{num,num}?`, 匹配尽可能少的内容, 只需要满足下限, 匹配就能成功.
- 占有优先量词: `*+`、`++`、`?+`、`{num,num}+` (Java和PHP支持), 类似普通的匹配优先量词, 不过它们一旦匹配某些内容, 就不会"交还"(类似固化分组).
- `?`代表可选项. 把它加在一个字符的后面, 就表示此处容许出现这个字符, 不过它的出现并非匹配成功的必要条件. `?`只作用于之前紧邻的元素.
- `+` 表示之前紧邻的元素出现一次或多次.
- `*` 表示之前紧邻的元素出现任意多次, 或者不出现.
- `{n}` 重复n次
- `{n,}` 重复n次或更多次
- `{n,m}` 重复n到m次

## 字符组

- 一个字符组, 即使是排除型字符组, 也需要匹配一个字符.
- `[...]` 字符组匹配单个列出的字符.
- `[^...]` 排除型字符组表示”匹配一个未列出的字符”, 而不是”不要匹配列出的字符”. 脱字符`^`仅作为字符组内部第一个字符时才是元字符, 在其他位置则表示普通字符.
- `-`连字符是字符组的元字符, 表示一个范围, 如`[0-9]`表示匹配数字0到9. 连字符作为字符组的第一个或最后一个字符时表示普通字符'-', 如`[-0]`表示匹配字符'-'和数字0. 使用连字符表示范围时, 一般是根据字符所对应的ASCII码值大小所定, 码值小的在前, 码值大的在后, 否则是非法的, 如`[z-a]`是非法的.
- 字符组中`-`连字符是元字符, 其他元字符`.(?`等则表示普通字符, 如果要保留其特殊含义, 需要加反斜杠`\`进行转义, 如`[.]`匹配普通字符'.', `[\.]`则匹配任意字符(不同实现可能不一样).
- 字符组"子语言"的规范不同于正则表达式主体.
- 我们通常说的字符组在POSIX标准中称为方括号表达式. POSIX中的术语"字符组"是POSIX方括号表达式使用的几种特殊元字符序列之一. 如`[:lower:]`表示当前locale中的所有小写字母. 对英文文本来说, `[[:lower:]]`等于`[a-z]`.

### 字符组缩略表示法

- `\d` 数字, 等价于`[0-9]`
- `\D` 非数字, 等价于`[^0-9]`
- `\s`表示所有"空白字符"的字符组, 包括空格符, 制表符, 换行符, 回车符等, 即`[ \f\n\r\t\v]`
- `\S`非空白字符, 等价于`[^\s]`
- `\w`单词字符, 等价于 `[a-zA-Z0-9_]` (不同实现不一样, 有些系统的`\w`能匹配非ASCII字母)
- `\W`非单词字符, 等价于`[^\w]`

### 字符组运算

- 简单减法(.NET): `[[a-z]-[aeiou]]`
- 完整集合运算(Java)
  - AND: 对两个集合进行概念上的"与"运算, 只保留同时属于两个字符组的字符. 如`[\p{InThai}&&\P{Cn}]`, `[[a-z]&&[^aeiou]]`
  - OR: 容许用户以字符组方式在字符组中添加字符, 如`[abcxyz]`可以表示为`[[abc][xyz]]`, `[abc[xyz]]`或`[[abc]xyz]`等. OR用来把多个集合合并为新的集合.
- 通过环视功能模拟字符组集合运算. 如`[\p{InThai}&&[^\p{Cn}]]`可以写成`(?!\p{Cn})\p{InThai}`

## 分组, 捕获, 条件判断

- `(...)` 捕获分组, `\1` `\2`表示第一, 第二组括号匹配的文本(反向引用), 括号是按照开括号`(`从左到右的出现顺序进行的.
- `(?:exp)` 非捕获分组, 匹配exp, 不捕获匹配的文本, 也不给此分组分配组号. 避免了不必要的捕获操作, 提高了匹配效率.
- `(?<Name>...)` 命名捕获
  - `(?P<name>...)` Python/PHP语法. 如`\b(?P<Area>\d\d\d)`, Python使用`RegexObj.group("Area")`, PHP使用`$matches["Area"]`. 在正则表达式内部引用捕获的文本`(?P=Area)`
  - `(?<name>...)` .NET语法. 如`\b(?<Area>\d\d\d)`, 使用`RegexObj.Groups("Area")`. 在正则表达式内部引用捕获的文本`\k<Area>`
- `(?>...)` 固化分组. 固化分组的匹配与正常的匹配并无差别, 但是如果匹配进行到此结构之后(也就是, 进行到闭括号之后), 那么此结构体中的所有备用状态都会被放弃. 也就是说, 在固化分组匹配结束时, 它已经匹配的文本已经固化为一个单元, 只能作为整体被保留或放弃. 括号内的子表达式中未尝试过的备用状态都不复存在了, 所以回溯永远不能选择其中的状态(至少是, 当此结构匹配完成时, "锁定(locked in)"在其中的状态).
  - 在匹配过程中, 引擎退出固化分组时, 放弃的只是固化分组中创建的备用状态. 而之前创建的备用状态依然保留, 所以, 如果后来的回溯要求退回到之前的备用状态, 固化分组部分匹配的文本会全部交还.
  - 举个栗子:
<img src="https://raw.githubusercontent.com/tzstone/MarkdownPhotos/master/%E5%9B%BA%E8%AF%9D%E5%88%86%E7%BB%84%E7%9A%84%E4%BE%8B%E5%AD%90.jpeg" width="70%" height="50%" align=center />

- `(?if then|else)` 条件判断. if部分是特殊的条件表达式, then和else部分是普通的子表达式. 如果if部分测试为真, 则尝试then的表达式, 否则尝试else部分(else部分也可以不出现, 此时可以省略'|').
  - `测试对捕获型括号的特殊引用`. 如果if部分是一个括号中的编号, 而对应编号的捕获型括号参与了匹配, 其值为"true". "参与匹配"不等于"实际匹配了文本". 例如:
    - 匹配可能包含在`<...>`中的单词: `(<)?\w+(?(1)>)`可以, `(<?)\w+(?(1)>)`则不行. 因为第二个例子中捕获型括号不是可选的(其中的`<`才是), 无论`<`是否匹配了文本, 第一组捕获型括号都"参与匹配", 所以`(?(1)...)`中if部分总是"true".
  - `用环视做测试`: `(?(?<=NUM:)\d+|\w+)`会在`NUM:`之后的位置尝试匹配`\d+`, 而在其他位置匹配`\w+`

## 匹配模式

- `/g` 全局匹配, 第一次匹配成功后继续搜索其他匹配项, 直至找到所有匹配.
- `/m` 增强的行锚点, `^`和`$`会从字符串模式切换到逻辑行模式.(即`^`,`$`分别匹配一行的开始和结束). 支持此模式的程序通常还提供了`\A`和`\Z`, 它们的作用与与普通的`^`和`$`一样, 只是在此模式下它们的意义不会发生变化. 有些实现方式中, `$`和`\Z`能够匹配字符串内部的换行符, 不过通常会提供`\z`, 唯一匹配整个字符串的结尾位置.
- `/i` 不区分大小写
- `/u` Unicode模式(javascript的ES6新增), 用来正确处理大于`\uFFFF`的Unicode字符。也就是说，会正确处理四个字节的UTF-16编码
- `/y` 与`/g`都是全局匹配(javascript的ES6新增), 不同在于: lastIndex属性指定每次搜索的开始位置, `/g`从这个位置开始向后搜索, 直到发现匹配为止; 但是`/y`要求必须在lastIndex指定的位置发现匹配, 即y修饰符确保匹配必须从剩下的第一个位置开始
- `/x` 宽松排列(Perl支持)
- `/s` 单行文本模式(perl支持), 点号不受限制, 可以匹配任何字符(包括换行符).
- `(?#...)`和`#...` 注释模式
- `\Q...\E` (Java, PHP, Perl支持)文字文本(literal text)模式, 消除其中除`\E`之外所有元字符的特殊含义, 其中的所有字符都会被当成普通文字文本来对待.

### 模式修饰符`(?modifier)`

- 许多流派容许在正则表达式中设定匹配模式. 如`(?i)`会启用不区分大小写的匹配, 而`(?-i)`会停用此功能. 例如, `<B>(?i)very(?-i)</B>`会对中间的`very`进行不区分大小写的匹配. 常见的模式修饰符字母:
  - `i` 不区分大小写的匹配模式
  - `x` 宽松排列和注释模式
  - `s` 点号通配模式
  - `m` 增强的行锚点模式

- 模式作用范围`(?modifier:...)`, 如`(?i:...)`表示模式修饰符的作用范围只有在括号内有效.

## 环视(lookaround)

- 环视结构不匹配任何字符, 只匹配文本中的特定位置.
- 环视不会"占用"字符. 即在检查子表达式能否匹配的过程中, 它们本身不会"占用"任何文本.
- 环视不会匹配字符, 但环视中的分组仍然会被捕获. 如`(?=(\d{3})+(?!\d))`中会捕获`(\d{3})`
- 环视结构中的子表达式会保存备用状态, 进行必要的回溯. 如果环视结构的匹配尝试结束(成功或失败), 在尝试中创造的所有备用状态都会被放弃(放弃备用状态这一点类似固化分组和占有优先量词).
  - 用肯定环视模拟固化分组: `(?=(regex))\1`可模拟`(?>regex)`
- 顺序环视顺序(从左至右)查看文本, 尝试匹配子表达式, 如果能够匹配, 就返回匹配成功信息.
  - `(?=exp)` 肯定型顺序环视, 表示如果当前位置右边的字符能匹配`exp`则匹配成功
  - `(?!exp)` 否定型顺序环视, `exp`不能匹配右侧文本
- 逆序环视逆序(从右向左)查看文本, 尝试匹配子表达式, 如果能够匹配, 就返回匹配成功信息.
  - `(?<=exp)` 肯定型逆序环视, 表示如果当前位置左边的字符能匹配`exp`则匹配成功
  - `(?<!exp)` 否定型逆序环视, `exp`不能匹配左侧文本

## 组合字符

- 一个字符在Unicode中可能由两个代码点构成. 如`à`在Unicode中由U+0061(`a`)和钝重音U+0300(`̀`, 组合字符)构成. Unicode提供了许多组合字符, 用来修饰(结合)一个基本字符.
- 许多程序把"字符"和"代码点"视为等价, 也就是说, 点号可以匹配单个的代码点, 无论是基本字符还是组合字符. 所以`à`能够由`^..$`匹配, 而不是`^.$`
- 如果有两个代码点的字符, 后面跟有一个量词, 量词作用的其实是第二个代码点.
- Perl和PHP支持使用`\X`缩略表示`\P{M}\p{M}*`, 它可以视为点号的扩展. 它匹配一个基本字符, 之后可能有任意数目的组合字符. `\P{M}`匹配不是组合字符的代码点, `\p{M}*`匹配零个或多个组合字符的代码点.
  - `\X`始终能匹配换行符和其他Unicode行终结符
  - `\X`不能匹配以组合字符开头的字符

## Unicode属性, 字母表, 区块

- Unicode是一套字符映射规则, 它还定义了每个字符的性质(qualities).

<img src="https://raw.githubusercontent.com/tzstone/MarkdownPhotos/master/%E5%9F%BA%E6%9C%AC%E7%9A%84Unicode%E5%B1%9E%E6%80%A7%E5%88%86%E7%B1%BB.jpeg" width="70%" height="50%" align=center />


- 字母表(Scripts) 有的系统能够按照字母表(书写系统 writing system)的名字以`\p{...}`来匹配. 例如, 用`\p{Hebrew}`匹配希伯来文独有的字符
  - 字母表不会包含特定的书写系统中的所有字符, 而只包含独属于(或者计划独属于)此书写系统中的字符. 常见的字符, 例如空格和标点不属于任何字母表, 而是属于通用的IsCommon伪字母表, 用`\p{IsCommon}`匹配.
- 区块(Block), 表示Unicode字符映射表中一定范围内的代码点. 例如, Tibetan区块表是从`U+0F00`到`U+0FFF`的256个代码点. 其中的字符在perl中可以用`\p{InTibetan}`来匹配.

## 正则引擎

### 分类

- 主要分为两大类: DFA和NFA. POSIX标准出台后, 规定了正则表达式的应有行为, NFA需要修改才能符合标准, 所以粗略可以分为3类:
  - DFA(包括符合或不符合POSIX标准的)
  - 传统型NFA
  - POSIX NFA

### 匹配的规则(适用所有引擎)

- 优先选择最左端(最靠开头)的匹配结果
  - 由来: 匹配先从需要查找的字符串的起始位置尝试匹配. 尝试匹配的意思是, 在当前位置测试整个正则表达式能匹配的每样文本. 如果在当前位置测试了所有的可能之后不能找到匹配结果, 就需要从字符串的第二个字符之前的位置开始重新尝试. 在找到匹配结果以前必须在所有的位置重复此过程. 只有在尝试过所有的起始位置(直到字符串的最后一个字符)都不能找到匹配结果的情况下, 才会报告"匹配失败".
  - 该规则没有规定优先的匹配结果的长度
- 标准的匹配量词(`*`、`+`、`?`和`{n,m}`)是匹配优先的.
  - 总是尝试匹配尽可能多的字符, 直到匹配上限为止, 但为了整个表达式的匹配, 它们通常也需要"释放"(即"交还")一些字符.
    - `先来先服务`原则: 匹配优先的结构只会在被迫的情况下交还字符. 如用`^.*([0-9]+)`匹配"copyright 2003.", `$1`会捕获到`3`, 而不是`2003`, 因为`.*`优先匹配了所有字符, 在被迫交还了`3`后,`[0-9]+`已经能够匹配, 此时没有"必须"匹配的元素, 所以`.*`不会被迫交还`0`

### NFA引擎(非确定型有穷自动机): 表达式主导(regex-directed)

- 在子表达式与正则表达式的控制结构(多选分支, 括号以及匹配量词)的层级关系(layout)控制了整个匹配过程
- 例如, 用`to(nite|knight|night)`匹配文本"...tonight..."

 <img src="https://raw.githubusercontent.com/tzstone/MarkdownPhotos/master/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%BB%E5%AF%BC.jpeg" width="70%" height="50%" align=center />

### DFA引擎(确定型有穷自动机): 文本主导(text-directed)

- 扫描的字符串中的每个字符都对引擎进行了控制
- 如果引擎发现, 文本中出现的某个字符会令所有处理中的匹配可能失效, 就会返回某个之前保留的完整匹配. 如果不存在这样的完整匹配, 则要报告在当前位置无法匹配.
  - 如正则表达式`to(...)?`, 括号内的部分不是必须出现的, 但由于匹配优先的性质, 引擎会尝试匹配括号内的部分. 匹配过程中, 在尝试括号内的部分时, 完整匹配`('to')`已经保留下来, 以应付括号中的内容无法匹配的情况.
- 例如, 用`to(nite|knight|night)`匹配文本"...tonight..."

<img src="https://raw.githubusercontent.com/tzstone/MarkdownPhotos/master/%E6%96%87%E6%9C%AC%E4%B8%BB%E5%AF%BC.jpeg" width="70%" height="50%" align=center />

### NFA与DFA的比较

#### 预编译阶段

- 在使用正则表达式搜索之前, 两种引擎都会编译表达式. DFA会內建一张路线图(map), 描述"遇到这个和这个字符, 就该选择这个和那个可能的匹配". 字符串中的每个字符都会按照这张路线图来匹配. 有时候, 构造这张路线图可能需要相当的时间和内存. 相比之下, NFA的编译过程通常更快一些, 需要的内存也更少一些.

#### 匹配速度

- 对于简单文本的匹配测试, 两种引擎速度差不多. 一般来说, DFA的速度与正则表达式无关, 而NFA中两者直接相关.
  - 在NFA的匹配过程中, 目标文本中的某个字符可能会被正则表达式的不同部分重复检测(甚至有可能被同一部分反复检测). (NFA对于一个字符的输入可能存在多个以上的状态转移)
  - DFA引擎是确定型的, 目标文本中的每个字符只会检查(最多)一遍. 对于一个已经匹配的字符, 你无法知道它是否属于最终匹配(它可能属于最终会失败的匹配), 但因为引擎同时记录了所有可能的匹配, 这个字符只需要检测一次. (DFA对于每一个输入只存在一个选择)

#### 匹配结果

- `最左最长规则`: 在文本的某个特定位置有一个或多个匹配的可能, DFA会选择所有可能中能匹配最多文本的那个. 如`one(self)?(selfsufficient)?`来匹配字符串"oneselfsufficient". 传统型NFA会在第一次找到匹配时停下来, 所以返回`oneself`, POSIX NFA在第一次找到匹配后继续尝试其他所有可能(备用状态), 最后返回最长匹配文本`onselfsufficient`, DFA也会返回最长匹配文本`onselfsufficient`
  - 类似的, 在多选结构中, 传统型NFA是按序排列的(从左到右, 选择第一个匹配成功的分支), DFA和POSIX NFA是匹配优先的, 即总是匹配所有多选分支中能匹配最多文本的那个.
    - 有序排列的多选结构, 通过变换顺序, 可以实现匹配优先的功能. 如`(\.\d\d[1-9]|\.\d\d)\d*`等价于匹配优先的`(\.\d\d[1-9]?)\d*`

#### 匹配能力

- 传统型NFA支持忽略优先量词, DFA不支持, 忽略优先量词在POSIX NFA中没有意义(因为POSIX标准规定, 如果在字符串的某个位置存在多个可能的匹配, 应当返回的是最长的匹配)
- NFA支持占用优先量词, 固化分组, 环视, 有序的多选结构, DFA不支持
- NFA支持捕获型括号和回溯, DFA不支持
  - `回溯`: NFA会依次处理各个子表达式或组成元素, 遇到需要在多个可能成功的选项中进行选择的时候(如量词和多选结构), 它会选择其一, 同时记住其他选择, 以备返回时使用. 如果当前选项匹配成功, 且正则表达式余下部分也匹配成功, 则匹配结束. 如果当前选项匹配失败, 或者正则表达式后面的部分匹配失败, 那么引擎需要回溯到最后一个作出选择的地方, 选择其他备用选项继续尝试(`即把"当前状态"切换为最近保存的"备用状态"`). 这样, 引擎最终会尝试表达式的所有可能途径.
    - 如果需要在"进行尝试"和"跳过尝试"之间选择, 对于匹配优先量词, 引擎会优先选择"进行尝试", 而对于忽略优先量词, 会选择"跳过尝试".
    - 距离当前最近储存的选项就是当本地失败强制回溯时返回的. 使用的原则是LIFO(last in first out, 后进先出)
    - 回溯机制不但需要重新计算正则表达式和文本的对应位置, 也需要维护括号内的子表达式所匹配文本的状态(反向引用).
    - "备用状态"用来标记: 在需要的时候, 匹配可以从这里重新开始尝试. 它们保存了两个位置: 正则表达式中的位置, 和未尝试的分支在字符串中的位置.
      - 未进行回溯的匹配
      <img src="https://raw.githubusercontent.com/tzstone/MarkdownPhotos/master/%E6%9C%AA%E8%BF%9B%E8%A1%8C%E5%9B%9E%E6%BA%AF%E7%9A%84%E5%8C%B9%E9%85%8D.jpeg" width="70%" height="50%" align=center />

      - 忽略优先的匹配
      <img src="https://raw.githubusercontent.com/tzstone/MarkdownPhotos/master/%E5%BF%BD%E7%95%A5%E4%BC%98%E5%85%88%E7%9A%84%E5%8C%B9%E9%85%8D.jpeg" width="70%" height="50%" align=center />

      - 星号, 加号及回溯
        - 每次测试星号作用的元素之前, 引擎都会保存一个状态, 如果测试失败(或者测试进行下去遭遇失败), 还能够从保存的状态开始匹配.
      <img src="https://raw.githubusercontent.com/tzstone/MarkdownPhotos/master/%E6%98%9F%E5%8F%B7%2C%20%E5%8A%A0%E5%8F%B7%E5%8F%8A%E5%9B%9E%E6%BA%AF.jpeg" width="70%" height="50%" align=center />

## 正则表达式的匹配过程

1. `正则表达式编译`: 检查正则表达式的语法正确性, 如果正确, 就将其编译为内部形式(internal form)
2. `传动开始`: 传动装置将正则引擎"定位"到目标字符串的起始位置
3. `元素检测`: 引擎开始测试正则表达式和文本, 依次测试正则表达式的各个元素(component)
    - `相连元素`, 例如"Subject"中的"S", "u", "b", "j", "e"等等, 会依次尝试, 只有当某个元素匹配失败时才会停止
    - `量词修饰的元素`, 控制权在量词(检查量词是否应该继续匹配)和被限定的元素(测试能否匹配)之间轮换
    - 控制权在捕获型括号内外进行切换会带来一些开销. 括号内的表达式匹配的文本必须保留, 这样才能通过`$1`来引用. 因为一对括号可能属于某个回溯分支, 括号的状态就是用于回溯的状态的一部分, 所以进入和退出捕获型括号时需要修改状态
4. `寻找匹配结果`: 如果找到一个匹配结果, 传统型NFA会"锁定"在当前状态, 报告匹配成功. 而对POSIX NFA来说, 如果这个匹配是迄今为止最长的, 它会记住这个可能的匹配, 然后从**可用的保存状态**继续下去. 保存的状态都测试完毕之后返回最长的匹配
5. `传动装置的驱动过程`: 如果没有找到匹配, 传动装置就会驱动引擎, 从文本中的下一个字符开始新一轮的尝试(回到步骤3)
6. `匹配彻底失败`: 如果从目标字符串的每一个字符(包括最后一个字符之后的位置)开始的尝试都失败了, 就会报告匹配彻底失败.

## 实用技巧

- 集中关注在特定时刻真正容许匹配的字符
- 如果回溯会导致不期望, 与多选结构有关的匹配结果, 问题很可能在于, 任何成功的匹配都不过是多选分支的排列顺序造成的偶然结果
- 如果多个多选分支能够在同一位置匹配, 必须小心地排列顺序
- 对某个正则表达式进行细微的改动, 在某个实现方式中可能会带来速度的大幅提升, 而在另一个实现方式中大大降低速度.(不同的引擎可能以不同的方式来优化)

## 性能优化

- `避免重新编译`: 如避免在循环内创建正则表达式, 而是在循环外创建, 在循环内使用
- `使用非捕获型括号`: 如果不需要引用括号内的文本, 可以使用非捕获型括号`(?:...)`, 这样不但能够节省捕获的时间, 而且会减少回溯使用的状态的数量
- `不要滥用括号`: 在需要的时候使用括号, 在其他时候使用括号会阻止某些优化措施. 如不要用`(.)*`, 而是`.*`
- `不要滥用字符组`: 如不要使用只包含单个字符的字符组`[:]`
- `将锚点独立出来`: 添加锚点能够配合开头字符/字符串/字符识别优化, 节省大量不必要的工作.
  - `在表达式前面独立出^和\G`: `^(?:abc|123)`和`^abc|^123`在逻辑上是等价的, 但是许多正则引擎只会对第一个表达式使用优化.
  - `在表达式末尾独立出$`: 如使用`(?:abc|123)$`而不是`abc$|123$`
- `将文字文本独立出来`
  - 依靠正则引擎的能力来识别匹配成功必须的一些文字文本
  - `从量词中"提取"必须的元素`: 使用`xx*`代替`x+`能够暴露匹配必须的`x`, 又如`-{5,7}`可写成`-----{0,2}`
  - `"提取"多选结构开头的必须元素`: 用`th(?:is|at)`替代`(?:this|that)`
- `拆分正则表达式`: 有时候应用多个小正则表达式的速度比一个大正则表达式要快得多, 如小正则表达式可能会开启字符串/字符识别优化
- `使用固化分组和占用优先量词`: 在许多情况下, 固化分组和占用优先量词能够极大地提高匹配速度, 而且它们不会改变匹配结果
- `将最可能的匹配的多选分支放在前头`
- `化简量词优化`: 约束普通元素--例如文字字符或者字符组--的加号, 星号之类的量词, 通常要经过优化, 避免普通NFA引擎的大部分逐步处理开销. (如不要把`.*`写成`(?:.)*`)
- `限制匹配优先的作用范围`: 如果从`(\\.|[^\\"])*` => `(\\.|[^\\"]+)*`, 对传统型NFA来说, 能匹配成功的话会减少星号的迭代次数, 加快匹配速度. 但当无法匹配时, `(...+)*`星号和加号的共同作用会产生"指数级"种可能, 造成大量回溯. 而对POSIX NFA而言, 匹配成功/失败前, 都需要尝试所有的可能.
  - "消除循环"的通用模式`opening normal*(special normal*)* closing`: 如`"[^\\"]*(\\.[^\\"]*)*"`可消除上述的循环
    - special部分和normal部分匹配的开头不能重合, 这样special部分可用作检查点, 消除normal部分在`(...)*`的各轮迭代时匹配同样文本造成的不确定性
    - specail部分必须匹配至少一个字符
    - special部分必须是固化的. special部分匹配的文本不能由该部分的多次迭代完成
  - 使用固化分组和占用优先量词: `(...|...)*+`和`(?>(...|...)*)`

## 参考资料

- [<<精通正则表达式>>](https://book.douban.com/subject/2154713/)
- [正则表达式理论篇](https://aotu.io/notes/2016/11/17/regexp-theory/index.html)
