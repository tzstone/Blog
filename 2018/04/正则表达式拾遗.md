# 正则表达式拾遗

## 基础

- 括号的作用
  - 限制多选结构的范围
  - 将若干字符组合为一个单元, 受`?`、`*`、`+`等量词的作用
  - 捕获分组.
- "子表达式"指的是整个正则表达式中的一部分, 通常是括号内的表达式, 或者是由`|`分隔的多选分支. 严格来讲, 字符也可以是子表达式, 如`cat`中`c`、`a`、`t`都算子表达式.
- 转义的3种情况
  - `\`加上元字符, 表示匹配元字符所使用的普通字符(如`\*`匹配普通的星号)
  - `\`加上非元字符, 组成一种由具体实现方式规定其意义的元字符序列(如egrep中`\<`表示单词的起始边界)
  - `\`加上任意其他字符, 默认情况就是匹配此字符(反斜杠被忽略了)

## 元字符

- `^`匹配字符串的开始, `$`匹配字符串的结尾.
- `.` 匹配除换行符以外的任意字符
- `|` 多选结构, 可以包括很多字符, 但不能超越括号的界限(如`gr(a|e)y`).
- `\b` 单词分界符. 匹配一个位置, 该位置的一侧是单词, 另一侧不是单词. 单词是指`\w`, 即字母, 数字, 下划线.
- `\B` 非单词分界符
- `\G` (Perl支持)匹配上一次匹配结束的位置, 在第一次迭代时, `\G`匹配字符串的开头.
  - 如果匹配不成功, `\G`的匹配会重新指向字符串的起始位置.
- `\C` 匹配单个字节(Perl和PHP支持), 即使该字节位于某个多字节编码的字符之中(相反, 其他功能都是基于字符的).
- `\cx` 匹配x指示的控制字符, 要求x的值必须在a-z或A-Z范围内
- `\xn` 匹配n, n是一个十六进制转移码
- `\un` 匹配n, n是以四位十六进制数表示的Unicode字符

## 量词

- 量词限定了所作用元素的匹配次数. 量词作用的对象是它们之前紧邻的子表达式.
  - 一个字符组是一个"单元(unit)", 所以它后面可以加量词, 如`[0-9]+`
- 量词在正常情况下都是"匹配优先"的, 即匹配尽可能多的内容.
- 忽略优先量词: `*?`、`+?`、`??`、`{num,num}?`, 匹配尽可能少的内容, 只需要满足下限, 匹配就能成功.
- 占有优先量词: `*+`、`++`、`?+`、`{num,num}+`(Java和PHP支持), 类似普通的匹配优先量词, 不过它们一旦匹配某些内容, 就不会"交还"(类似固化分组).
- `?`代表可选项. 把它加在一个字符的后面, 就表示此处容许出现这个字符, 不过它的出现并非匹配成功的必要条件. `?`只作用于之前紧邻的元素.
- `+` 表示之前紧邻的元素出现一次或多次.
- `*` 表示之前紧邻的元素出现任意多次, 或者不出现.
- `{n}` 重复n次
- `{n,}` 重复n次或更多次
- `{n,m}` 重复n到m次

## 字符组

- 一个字符组, 即使是排除型字符组, 也需要匹配一个字符.
- `[...]` 字符组匹配单个列出的字符.
- `[^...]` 排除型字符组表示”匹配一个未列出的字符”, 而不是”不要匹配列出的字符”. 脱字符`^`仅作为字符组内部第一个字符时才是元字符, 在其他位置则表示普通字符.
- `-`连字符是字符组的元字符, 表示一个范围, 如`[0-9]`表示匹配数字0到9. 连字符作为字符组的第一个或最后一个字符时表示普通字符'-', 如`[-0]`表示匹配字符'-'和数字0. 使用连字符表示范围时, 一般是根据字符所对应的ASCII码值大小所定, 码值小的在前, 码值大的在后, 否则是非法的, 如`[z-a]`是非法的.
- 字符组中`-`连字符是元字符, 其他元字符`.(?`等则表示普通字符, 如果要保留其特殊含义, 需要加反斜杠`\`进行转义, 如`[.]`匹配普通字符'.', `[\.]`则匹配任意字符(不同实现可能不一样).
- 字符组"子语言"的规范不同于正则表达式主体.
- 我们通常说的字符组在POSIX标准中称为方括号表达式. POSIX中的术语"字符组"是POSIX方括号表达式使用的几种特殊元字符序列之一. 如`[:lower:]`表示当前locale中的所有小写字母. 对英文文本来说, `[[:lower:]]`等于`[a-z]`.

### 字符组缩略表示法

- `\d` 数字, 等价于`[0-9]`
- `\D` 非数字, 等价于`[^0-9]`
- `\s`表示所有"空白字符"的字符组, 包括空格符, 制表符, 换行符, 回车符等.
- `\S`非空白字符, 等价于`[^\s]`
- `\w`单词字符, 等价于 `[a-zA-Z0-9_]` (不同实现不一样, 有些系统的`\w`能匹配非ASCII字母)
- `\W`非单词字符, 等价于`[^\w]`

### 字符组运算

- 简单减法(.NET): `[[a-z]-[aeiou]]`
- 完整集合运算(Java)
  - AND: 对两个集合进行概念上的"与"运算, 只保留同时属于两个字符组的字符. 如`[\p{InThai}&&\P{Cn}]`, `[[a-z]&&[^aeiou]]`
  - OR: 容许用户以字符组方式在字符组中添加字符, 如`[abcxyz]`可以表示为`[[abc][xyz]]`, `[abc[xyz]]`或`[[abc]xyz]`等. OR用来把多个集合合并为新的集合.
- 通过环视功能模拟字符组集合运算. 如`[\p{InThai}&&[^\p{Cn}]]`可以写成`(?!\p{Cn})\p{InThai}`

## 分组, 捕获, 条件判断

- `(...)` 捕获分组, `\1` `\2`表示第一, 第二组括号匹配的文本(反向引用), 括号是按照开括号`(`从左到右的出现顺序进行的.
- `(?:exp)` 非捕获分组, 匹配exp, 不捕获匹配的文本, 也不给此分组分配组号. 避免了不必要的捕获操作, 提高了匹配效率.
- `(?<Name>...)` 命名捕获
  - `(?P<name>...)` Python/PHP语法. 如`\b(?P<Area>\d\d\d)`, Python使用`RegexObj.group("Area")`, PHP使用`$matches["Area"]`. 在正则表达式内部引用捕获的文本`(?P=Area)`
  - `(?<name>...)` .NET语法. 如`\b(?<Area>\d\d\d)`, 使用`RegexObj.Groups("Area")`. 在正则表达式内部引用捕获的文本`\k<Area>`
- `(?>...)` 固化分组. 一旦括号内的子表达式匹配之后, 匹配的内容就固定下来(固化(atomic)下来无法改变), 在接下来的匹配过程中不会变化, 除非整个固化分组的括号都被弃用, 在外部回溯中重新应用. 如:

![固话分组的例子](https://raw.githubusercontent.com/tzstone/MarkdownPhotos/master/%E5%9B%BA%E8%AF%9D%E5%88%86%E7%BB%84%E7%9A%84%E4%BE%8B%E5%AD%90.jpeg)

- `(?if then|else)` 条件判断. if部分是特殊的条件表达式, then和else部分是普通的子表达式. 如果if部分测试为真, 则尝试then的表达式, 否则尝试else部分(else部分也可以不出现, 此时可以省略'|').
  - `测试对捕获型括号的特殊引用`. 如果if部分是一个括号中的编号, 而对应编号的捕获型括号参与了匹配, 其值为"true". "参与匹配"不等于"实际匹配了文本". 例如:
    - 匹配可能包含在`<...>`中的单词: `(<)?\w+(?(1)>)`可以, `(<?)\w+(?(1)>)`则不行. 因为第二个例子中捕获型括号不是可选的(其中的`<`才是), 无论`<`是否匹配了文本, 第一组捕获型括号都"参与匹配", 所以`(?(1)...)`中if部分总是"true".
  - `用环视做测试`: `(?(?<=NUM:)\d+|\w+)`会在`NUM:`之后的位置尝试匹配`\d+`, 而在其他位置匹配`\w+`

## 匹配模式

- `/g` 全局匹配, 第一次匹配成功后继续搜索其他匹配项, 直至找到所有匹配.
- `/m` 增强的行锚点, `^`和`$`会从字符串模式切换到逻辑行模式.(即`^`,`$`分别匹配一行的开始和结束). 支持此模式的程序通常还提供了`\A`和`\Z`, 它们的作用与与普通的`^`和`$`一样, 只是在此模式下它们的意义不会发生变化. 有些实现方式中, `$`和`\Z`能够匹配字符串内部的换行符, 不过通常会提供`\z`, 唯一匹配整个字符串的结尾位置.
- `/i` 不区分大小写
- `/x` 宽松排列(Perl支持)
- `/s` 单行文本模式(perl支持), 点号不受限制, 可以匹配任何字符(包括换行符).
- `(?#...)`和`#...` 注释模式
- `\Q...\E` (Java, PHP, Perl支持)文字文本(literal text)模式, 消除其中除`\E`之外所有元字符的特殊含义, 其中的所有字符都会被当成普通文字文本来对待.

### 模式修饰符`(?modifier)`

- 许多流派容许在正则表达式中设定匹配模式. 如`(?i)`会启用不区分大小写的匹配, 而`(?-i)`会停用此功能. 例如, `<B>(?i)very(?-i)</B>`会对中间的`very`进行不区分大小写的匹配. 常见的模式修饰符字母:
  - `i` 不区分大小写的匹配模式
  - `x` 宽松排列和注释模式
  - `s` 点号通配模式
  - `m` 增强的行锚点模式

- 模式作用范围`(?modifier:...)`, 如`(?i:...)`表示模式修饰符的作用范围只有在括号内有效.

## 环视(lookaround)

- 环视结构不匹配任何字符, 只匹配文本中的特定位置. 环视不会消耗字符.
- 环视不会匹配字符, 但环视中的分组仍然会被捕获. 如`(?=(\d{3})+(?!\d))`中会捕获`(\d{3})`
- 顺序环视顺序(从左至右)查看文本, 尝试匹配子表达式, 如果能够匹配, 就返回匹配成功信息.
  - `(?=exp)` 肯定型顺序环视, 表示如果当前位置右边的字符能匹配`exp`则匹配成功
  - `(?!exp)` 否定型顺序环视, `exp`不能匹配右侧文本
- 逆序环视逆序(从右向左)查看文本, 尝试匹配子表达式, 如果能够匹配, 就返回匹配成功信息.
  - `(?<=exp)` 肯定型逆序环视, 表示如果当前位置左边的字符能匹配`exp`则匹配成功
  - `(?<!exp)` 否定型逆序环视, `exp`不能匹配左侧文本

## 组合字符

- 一个字符在Unicode中可能由两个代码点构成. 如`à`在Unicode中由U+0061(`a`)和钝重音U+0300(`̀`, 组合字符)构成. Unicode提供了许多组合字符, 用来修饰(结合)一个基本字符.
- 许多程序把"字符"和"代码点"视为等价, 也就是说, 点号可以匹配单个的代码点, 无论是基本字符还是组合字符. 所以`à`能够由`^..$`匹配, 而不是`^.$`
- 如果有两个代码点的字符, 后面跟有一个量词, 量词作用的其实是第二个代码点.
- Perl和PHP支持使用`\X`缩略表示`\P{M}\p{M}*`, 它可以视为点号的扩展. 它匹配一个基本字符, 之后可能有任意数目的组合字符. `\P{M}`匹配不是组合字符的代码点, `\p{M}*`匹配零个或多个组合字符的代码点.
  - `\X`始终能匹配换行符和其他Unicode行终结符
  - `\X`不能匹配以组合字符开头的字符

## Unicode属性, 字母表, 区块

- Unicode是一套字符映射规则, 它还定义了每个字符的性质(qualities).

![基本的Unicode属性分类](https://raw.githubusercontent.com/tzstone/MarkdownPhotos/master/%E5%9F%BA%E6%9C%AC%E7%9A%84Unicode%E5%B1%9E%E6%80%A7%E5%88%86%E7%B1%BB.jpeg)

- 字母表(Scripts) 有的系统能够按照字母表(书写系统 writing system)的名字以`\p{...}`来匹配. 例如, 用`\p{Hebrew}`匹配希伯来文独有的字符
  - 字母表不会包含特定的书写系统中的所有字符, 而只包含独属于(或者计划独属于)此书写系统中的字符. 常见的字符, 例如空格和标点不属于任何字母表, 而是属于通用的IsCommon伪字母表, 用`\p{IsCommon}`匹配.
- 区块(Block), 表示Unicode字符映射表中一定范围内的代码点. 例如, Tibetan区块表是从`U+0F00`到`U+0FFF`的256个代码点. 其中的字符在perl中可以用`\p{InTibetan}`来匹配.

## 正则引擎

### 匹配的规则(适用所有引擎)

- 优先选择最左端(最靠开头)的匹配结果
  - 由来: 匹配先从需要查找的字符串的起始位置尝试匹配. 尝试匹配的意思是, 在当前位置测试整个正则表达式能匹配的每样文本. 如果在当前位置测试了所有的可能之后不能找到匹配结果, 就需要从字符串的第二个字符之前的位置开始重新尝试. 在找到匹配结果以前必须在所有的位置重复此过程. 只有在尝试过所有的起始位置(直到字符串的最后一个字符)都不能找到匹配结果的情况下, 才会报告"匹配失败".
  - 该规则没有规定优先的匹配结果的长度
- 标准的匹配量词(`*`、`+`、`?`和`{n,m}`)是匹配优先的.
  - 总是尝试匹配尽可能多的字符, 直到匹配上限为止, 但为了整个表达式的匹配, 它们通常也需要"释放"(即"交还")一些字符.
    - `先来先服务`原则: 匹配优先的结构只会在被迫的情况下交还字符. 如用`^.*([0-9]+)`匹配"copyright 2003.", `$1`会捕获到`3`, 而不是`2003`, 因为`.*`优先匹配了所有字符, 在被迫交还了`3`后,`[0-9]+`已经能够匹配, 此时没有"必须"匹配的元素, 所以`.*`不会被迫交还`0`

### NFA引擎(非确定型有穷自动机): 表达式主导(regex-directed)

- 在子表达式与正则表达式的控制结构(多选分支, 括号以及匹配量词)的层级关系(layout)控制了整个匹配过程
- 例如, 用`to(nite|knight|night)`匹配文本"...tonight..."

![表达式主导](https://raw.githubusercontent.com/tzstone/MarkdownPhotos/master/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%BB%E5%AF%BC.jpeg)

### DFA引擎(确定型有穷自动机): 文本主导(text-directed)

- 扫描的字符串中的每个字符都对引擎进行了控制
- 如果引擎发现, 文本中出现的某个字符会令所有处理中的匹配可能失效, 就会返回某个之前保留的完整匹配. 如果不存在这样的完整匹配, 则要报告在当前位置无法匹配.
  - 如正则表达式`to(...)?`, 括号内的部分不是必须出现的, 但由于匹配优先的性质, 引擎会尝试匹配括号内的部分. 匹配过程中, 在尝试括号内的部分时, 完整匹配`('to')`已经保留下来, 以应付括号中的内容无法匹配的情况.
- 例如, 用`to(nite|knight|night)`匹配文本"...tonight..."

<img src="https://raw.githubusercontent.com/tzstone/MarkdownPhotos/master/%E6%96%87%E6%9C%AC%E4%B8%BB%E5%AF%BC.jpeg" width="70%" height="50%" align=center>

### NFA与DFA的比较

- 一般情况下, DFA引擎会更快.
  - 在NFA的匹配过程中, 目标文本中的某个字符可能会被正则表达式的不同部分重复检测(甚至有可能被同一部分反复检测). (NFA对于一个字符的输入可能存在多个以上的状态转移)
  - DFA引擎是确定型的, 目标文本中的每个字符只会检查(最多)一遍. 对于一个已经匹配的字符, 你无法知道它是否属于最终匹配(它可能属于最终会失败的匹配), 但因为引擎同时记录了所有可能的匹配, 这个字符只需要检测一次. (DFA对于每一个输入只存在一个选择)
- NFA支持忽略优先量词, 支持捕获型括号和回溯, 但DFA不支持
  - `回溯`: NFA会依次处理各个子表达式或组成元素, 遇到需要在多个可能成功的选项中进行选择的时候(如量词和多选结构), 它会选择其一, 同时记住其他选择, 以备返回时使用. 如果当前选项匹配成功, 且正则表达式余下部分也匹配成功, 则匹配结束. 如果当前选项匹配失败, 或者正则表达式后面的部分匹配失败, 那么引擎需要回溯到最后一个作出选择的地方, 选择其他备用选项继续尝试(`即把"当前状态"切换为最近保存的"备用状态"`). 这样, 引擎最终会尝试表达式的所有可能途径.
    - 如果需要在"进行尝试"和"跳过尝试"之间选择, 对于匹配优先量词, 引擎会优先选择"进行尝试", 而对于忽略优先量词, 会选择"跳过尝试".
    - 距离当前最近储存的选项就是当本地失败强制回溯时返回的. 使用的原则是LIFO(last in first out, 后进先出)
    - "备用状态"用来标记: 在需要的时候, 匹配可以从这里重新开始尝试. 它们保存了两个位置: 正则表达式中的位置, 和未尝试的分支在字符串中的位置. 如用`ab?c`匹配"abc", 匹配完`a`之后, 轮到`b?`时, 引擎会把
    ![备用状态](https://raw.githubusercontent.com/tzstone/MarkdownPhotos/master/%E5%A4%87%E7%94%A8%E7%8A%B6%E6%80%81.jpeg)
    添加到备用状态序列中.
