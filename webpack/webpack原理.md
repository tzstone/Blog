# webpack 原理

## webpack 是什么?

![](https://github.com/tzstone/MarkdownPhotos/raw/master/webpack.png)

本质上,webpack 是一个现代 JavaScript 应用程序的`静态模块打包器`(module bundler)。当 webpack 处理应用程序时, 它会递归地构建一个`依赖关系图`(dependency graph), 其中包含应用程序需要的每个模块, 然后将所有这些模块打包成一个或多个 bundle。

webpack 就像一条生产线, 要经过一系列处理流程后才能将源文件转换成输出结果。这条生产线上的每个处理流程的职责都是单一的, 多个流程之间有存在依赖关系, 只有完成当前处理后才能交给下一个流程去处理。插件就像是一个插入到生产线中的一个功能, 在特定的时机对生产线上的资源做处理。

webpack 通过 `Tapable` 来组织这条复杂的生产线。 webpack 在运行过程中会`广播事件`, 插件只需要监听它所关心的事件, 就能加入到这条生产线中, 去改变生产线的运作。webpack 的事件流机制保证了插件的有序性, 使得整个系统扩展性很好。

## 核心概念

- `entry`: 一个可执行模块或库的入口文件。
- `module`：模块，在 webpack 里一切皆模块，一个模块对应着一个文件。webpack 会从配置的 entry 开始递归找出所有依赖的模块。
- `chunk`: 代码块，一个 chunk 由多个模块组合而成，用于代码合并与分割, 这体现了 webpack 的打包机制。
- `loader`: 模块转换器，用于把模块原内容按照需求转换成新内容，让 webpack 能够去处理那些非 JavaScript 文件（webpack 自身只理解 JavaScript）, 例如把 es6 转换为 es5，scss 转换为 css。
- `plugin`: 扩展插件，在 webpack 构建流程中的特定时机会广播出对应的事件，插件可以监听这些事件的发生，在特定时机做对应的事情。
- `output`：输出结果，在 webpack 经过一系列处理并得出最终想要的代码后输出结果。

Webpack 启动后会从 Entry 里配置的 Module 开始递归解析 Entry 依赖的所有 Module。每找到一个 Module，就会根据配置的 Loader 去找出对应的转换规则，对 Module 进行转换后，再解析出当前 Module 依赖的 Module。这些模块会以 Entry 为单位进行分组，一个 Entry 和其所有依赖的 Module 被分到一个组也就是一个 Chunk。最后 Webpack 会把所有 Chunk 转换成文件输出。在整个流程中 Webpack 会在恰当的时机执行 Plugin 里定义的逻辑。

## 构建流程

Webpack 的运行流程是一个串行的过程，从启动到结束会依次执行以下流程：

1. 初始化参数：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数；
2. 开始编译：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件(好让插件监听 webpack 构建生命周期的事件节点)，执行对象的 run 方法开始执行编译；
3. 确定入口：根据配置中的 entry 找出所有的入口文件；
4. 编译模块：从入口文件出发，开始解析文件构建 AST 语法树，找出每个文件(模块)所依赖的模块(文件)，递归下去。在解析模块递归的过程中根据模块类型和 loader 配置找出合适的 loader 用来对模块进行转换。
5. 完成模块编译：在经过第 4 步使用 loader 转换完所有模块后，得到了每个模块被转换后的最终内容以及它们之间的依赖关系；
6. 输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会；
7. 输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。

在以上过程中，Webpack 会在特定的时间点广播出特定的事件，插件在监听到感兴趣的事件后会执行特定的逻辑，并且插件可以调用 Webpack 提供的 API 改变 Webpack 的运行结果。比如 UglifyJsPlugin 会在 loader 转换递归完后对结果再使用 UglifyJs 压缩覆盖之前的结果。

上述的构建流程可以分为以下三大阶段：

1. 初始化：启动构建，读取与合并配置参数，加载 Plugin，实例化 Compiler。
2. 编译：从 Entry 发出，针对每个 Module 串行调用对应的 Loader 去翻译文件内容，再找到该 Module 依赖的 Module，递归地进行编译处理。
3. 输出：对编译后的 Module 组合成 Chunk，把 Chunk 转换成文件，输出到文件系统。

如果只执行一次构建，以上阶段将会按照顺序各执行一次。但在开启监听模式下，流程将变为如下：

![](https://github.com/tzstone/MarkdownPhotos/raw/master/webpack_process.png)

在每个大阶段中又会发生很多事件，Webpack 会把这些事件广播出来供给 Plugin 使用(基于 webpack 3.8.1 版本):

### 初始化阶段

| 事件名          | 解释                                                                                                                                               |
| --------------- | -------------------------------------------------------------------------------------------------------------------------------------------------- |
| 初始化参数      | 从配置文件和 Shell 语句中读取与合并参数，得出最终的参数。 这个过程中还会执行配置文件中的插件实例化语句 new Plugin()。                              |
| 实例化 Compiler | 用上一步得到的参数初始化 Compiler 实例，Compiler 负责文件监听和启动编译。Compiler 实例中包含了完整的 Webpack 配置，全局只有一个 Compiler 实例。    |
| 加载插件        | 依次调用插件的 apply 方法，让插件可以监听后续的所有事件节点。同时给插件传入 compiler 实例的引用，以方便插件通过 compiler 调用 Webpack 提供的 API。 |
| environment     | 开始应用 Node.js 风格的文件系统到 compiler 对象，以方便后续的文件寻找和读取。                                                                      |
| entry-option    | 读取配置的 Entrys，为每个 Entry 实例化一个对应的 EntryPlugin，为后面该 Entry 的递归解析工作做准备。                                                |
| after-plugins   | 调用完所有内置的和配置的插件的 apply 方法。                                                                                                        |
| after-resolvers | 根据配置初始化完 resolver，resolver 负责在文件系统中寻找指定路径的文件。                                                                           |

### 编译阶段

| 事件名        | 解释                                                                                                                                                                                                      |
| ------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| run           | 启动一次新的编译。                                                                                                                                                                                        |
| watch-run     | 和 run 类似，区别在于它是在监听模式下启动的编译，在这个事件中可以获取到是哪些文件发生了变化导致重新启动一次新的编译。                                                                                     |
| compile       | 该事件是为了告诉插件一次新的编译将要启动，同时会给插件带上 compiler 对象。                                                                                                                                |
| compilation   | 当 Webpack 以开发模式运行时，每当检测到文件变化，一次新的 Compilation 将被创建。一个 Compilation 对象包含了当前的模块资源、编译生成资源、变化的文件等。Compilation 对象也提供了很多事件回调供插件做扩展。 |
| make          | 一个新的 Compilation 创建完毕，即将从 Entry 开始读取文件，根据文件类型和配置的 Loader 对文件进行编译，编译完后再找出该文件依赖的文件，递归的编译和解析。                                                  |
| after-compile | 一次 Compilation 执行完成。                                                                                                                                                                               |
| invalid       | 当遇到文件不存在、文件编译错误等异常时会触发该事件，该事件不会导致 Webpack 退出。                                                                                                                         |

在编译阶段中，最重要的要数 compilation 事件了，因为在 compilation 阶段调用了 Loader 完成了每个模块的转换操作，在 compilation 阶段又包括很多小的事件，它们分别是：

| 事件名               | 解释                                                                                                                                                            |
| -------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| build-module         | 使用对应的 Loader 去转换一个模块。                                                                                                                              |
| normal-module-loader | 在用 Loader 对一个模块转换完后，使用 acorn 解析转换后的内容，输出对应的抽象语法树（AST），以方便 Webpack 后面对代码的分析。                                     |
| program              | 从配置的入口模块开始，分析其 AST，当遇到 require 等导入其它模块语句时，便将其加入到依赖的模块列表，同时对新找出的依赖模块递归分析，最终搞清所有模块的依赖关系。 |
| seal                 | 所有模块及其依赖的模块都通过 Loader 转换完成后，根据依赖关系开始生成 Chunk。                                                                                    |

### 输出阶段

| 事件名      | 解释                                                                                                              |
| ----------- | ----------------------------------------------------------------------------------------------------------------- |
| should-emit | 所有需要输出的文件已经生成好，询问插件哪些文件需要输出，哪些不需要。                                              |
| emit        | 确定好要输出哪些文件后，执行文件输出，可以在这里获取和修改输出内容。                                              |
| after-emit  | 文件输出完毕。                                                                                                    |
| done        | 成功完成一次完成的编译和输出流程。                                                                                |
| failed      | 如果在编译和输出流程中遇到异常导致 Webpack 退出时，就会直接跳转到本步骤，插件可以在本事件中获取到具体的错误原因。 |

在输出阶段已经得到了各个模块经过转换后的结果和其依赖关系，并且把相关模块组合在一起形成一个个 Chunk。 在输出阶段会根据 Chunk 的类型，使用对应的模版生成最终要要输出的文件内容。

参考资料:

[深入浅出 webpack](https://webpack.wuhaolin.cn/)

[webpack 原理与实战](https://github.com/gwuhaolin/blog/issues/4)

[看完就懂 webpack 打包原理](https://my.oschina.net/incess/blog/3159342)

[Webpack 原理浅析](https://aotu.io/notes/2020/07/17/webpack-analize/index.html)
